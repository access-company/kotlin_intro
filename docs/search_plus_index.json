{"overview.html":{"url":"overview.html","title":"はじめに","keywords":"","body":"はじめに 本ドキュメントは、株式会社 ACCESS 新卒研修において、Kotlin のレクチャを行う目的で作成しています。 文書について 以下のリポジトリで公開しています。https://github.com/access-company/kotlin_intro/ 誤り、改善点などあれば、issue、Pull request でのご指摘にご協力をお願いいたします。 参考文献 以下を参考にして作成されています。 Kotlin スタートブック Kotlin Docs Kotlin koans たくさん課題があるので、一通りやってみるととても良い！ "},"about_kotlin.html":{"url":"about_kotlin.html","title":"Kotlin について","keywords":"","body":"Kotlin について 生い立ち JetBrains 社が中心となって開発を行っているプログラミング言語 2011年夏に発表。現在は OSS (github のリポジトリ) として開発されている ライセンスは Apache 2.0 2025年4月1日現在、Kotlin はバージョン 2.1 2.1.20 が最新 どんな言語か JVM 言語 コンパイルすると Java バイトコードになる Scala、Groovy なんかも JVM 言語 Java 互換 100％ Java で作られたライブラリを呼び出すことができる 逆に、Kotlin で作られたライブラリを Java から呼び出すこともできる なので、「Java か Kotlin か」ではなく、共存が可能 静的型付け (コンパイルしない系の言語に比べて) コンパイル時に誤りが発見されるという利点 オブジェクト指向 いわゆる C++、Java 等と同様で、クラスベースのオブジェクト指向言語 Android Studio 3.0 で標準サポート 初期 (2016〜2018年頃) はもっぱら Android のアプリ作成に用いられていた 徐々に他のプラットフォーム、サーバーサイド、Web、システムプログラミングでも使われ始めた モダンな言語仕様 型推論、ラムダ式、トレイトなど (Kotlin 1.2 から) JavaScript へのトランスパイルもサポート Java ではなくて Kotlin を使う理由 Java より記述が簡潔 型推論、スマートキャスト、等の言語仕様 Android 向け開発で使える Java の機能は Java 8 あたりまでしかサポートされておらず、それ以降にサポートされた新しい Java の機能は基本的に利用できない Java より安全 Null安全、キャスト周りの安全性 Kotlin はポータブル Kotlin Multiplatform を利用すると、Kotlin で書いた一つのコードを Android と iOS と Web フロントエンドで使い回したりすることができる "},"basic_syntax.html":{"url":"basic_syntax.html","title":"基本的な文法","keywords":"","body":"基本的な文法 Kotlin の基本的な文法について記載します。 ゴール 以下について、使い方を理解すること。 変数宣言 (var、val) 基本的なデータ型 基本的なデータ構造 (文字列、配列、リスト、セット、マップ、レンジ) 条件分岐 (if、when) ループ (while、for) Kotlin Playground ブラウザ上でコードを書いて動作確認できます。 https://play.kotlinlang.org このサイトにも Playground のスクリプトを埋め込んでいます。 fun main(args: Array) { println(\"Hello world!\") } ↑ためしにHello あなたの名前!に書き変えて、緑矢印を押してください。 いろんな型 主に使われる型と、値の例を以下に記載 数値型 型名 ビット幅 用途 例 備考 Byte 8 bit 整数 0x0f, 0b0101, 123 -128 ~ 127 Short 16 bit 整数 0x0f, 0b0101, 1234 -32,768 ~ 32767 Int 32 bit 整数 0x0f, 0b0101, 1234 -2,147,483,648 ~ 2,147,483,647 Long 64 bit 整数 123456789L -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 Float 32 bit 浮動小数点 123.456F 単精度浮動小数点 Double 64 bit 浮動小数点 123.456 倍精度不動小数点 ちなみに、数値は読みやすさ向上のために任意の位置に _ を補った書き方ができる Int の最大値 → 2_147_483_674 クレジットカード番号 → 1234_5678_9012 マイナンバー → 987_65_4321 16進数を 1 byte ずつ区切る → 0xFF_EE_DD_CC 2進数を 1 byte ずつ区切る → 0b11010101_01011111_01010101 その他の基本型 型名 用途 例 Char 文字 'a', 'b', '0', '\\u8d64' String 文字列 \"hello\", \"How are you!\" Boolean 真偽値 true, false Unit \"ない\"ことを表す (Java の void にあたる) fun hoge(): Unit(戻り値がない関数の定義) 変数 val val で宣言した変数は、あとから値の変更 (再代入) ができない。 変数を扱う際には、可能な限りは val を用いたほうが良い。 var はコードの読みにくさやバグを招きやすい。 fun main(args: Array) { //sampleStart // val 変数名: 型 = 式 val foo: Int = 123 val bar: String = \"Hello\" println(\"foo=$foo, bar=$bar\") //sampleEnd } var var で宣言した変数は再代入が可能。 fun main(args: Array) { //sampleStart // var 変数名: 型 = 式 var foo: Int = 123 var bar: String = \"Hello\" // あとから値が変えられる foo = 100 bar = \"World!\" println(\"foo=$foo, bar=$bar\") //sampleEnd } 型推論 Kotlin コンパイラに、右辺から変数の型を推論してもらうことができる。 型推論を行う場合は、型名を省略して代入を行う。 fun main(args: Array) { //sampleStart val age = 35 // age の型は Int になる var name = \"access\" // name の型は String になる name = 12 // name の型は String なのでコンパイルエラーになる println(\"name=$name, age=$age\") //sampleEnd } オブジェクト オブジェクトとは？→クラスのページで詳しく触れる。 文字列 (String) 文字列を表すオブジェクト。 色々なメソッド、プロパティが取り揃えられている。 String - Kotlin Programming Language (公式 API Reference) fun main(args: Array) { //sampleStart val str = \"access\" println(str.length) // 6 println(str.capitalize()) // \"Access\" println(str.isEmpty()) // false // 文字列の連結 val str2 = \"Hello \" + str + \" !\" // + を使った連結 println(str2) // \"Hello access !\" val str3 = \"Good evening $str!\" // String テンプレートを使った連結 println(str3) // \"Good evening access! val str4 = \"Good night ${str}!\" // String テンプレートを使った連結 println(str4) // \"Good night access! val str5 = \"1 + 1 = ${1 + 1}\" // String テンプレートを使った計算 println(str5) // \"1 + 1 = 2\" //sampleEnd } 配列 fun main(args: Array) { //sampleStart // 配列を作るには arrayOf を使う // 配列の中身の型は推論される // 以下は String の配列ということにされる val array = arrayOf(\"access\", \"company\", \"com\") println(array[0]) // \"access\" println(array[1]) // \"company\" println(array[2]) // \"com\" // 配列の要素を後から変更することもできる array[2] = \"jp\" println(array[2]) // \"jp\" // 配列に後から要素を足したり減らしたりすることはできない //sampleEnd } リスト fun main(args: Array) { //sampleStart // listOf でリストを作る。 val list = listOf(1, 2, 3) // 配列と同じように要素アクセスできる println(list[0]) // 1 // 単なるリストは要素の値を変更できない // 要素の値を変更可能なリストが欲しい場合は MutableList を使う // listOf を mutableListOf に変えてみよう list[0] = 100 // コンパイルエラー println(list[0]) // MutableList なら要素を足したり減らしたりもできる list.removeFirst() list.add(4) println(list) //sampleEnd } セット fun main(args: Array) { //sampleStart // セットは「重複のない」集合を扱う場合に用いる val intSet = setOf(1, 2, 3, 4, 1, 3, 2) println(intSet) // [1, 2, 3, 4] // 単なるセットは要素の値を変更できない // 要素を追加したり削除したりする場合は MutableSet を用いる // setOf を mutableSetOf に変えてみよう intSet += 5 // コンパイルエラー println(intSet) // セットは要素の順番を保証しないので、配列みたいな添字での要素アクセスはできない // intSet[2] を intSet.toList() に変えてみよう println(intSet[2]) // コンパイルエラー //sampleEnd } マップ fun main(args: Array) { //sampleStart // マップはキーと値のペアを保持するコレクション // 以下は という形のペアを保持できるマップ val map = mapOf(1 to \"access\", 2 to \"company\", 3 to \"com\") println(map[1]) // \"access\" println(map[2]) // \"company\" println(map[3]) // \"com\" println(map[4]) // null // ご多分に漏れず、単なるマップは値の変更ができない // 要素の値を変更可能なマップが欲しい場合は MutableMap を使う // mapOf を mutableMapOf に変えてみよう map[1] = \"fuga\" // コンパイルエラー println(map[1]) //sampleEnd } レンジ .. を使って範囲を表すことができる fun main(args: Array) { //sampleStart // 1..10 で、 1〜10 の範囲を示す // in を使って、指定した値が範囲内にあるかチェックする println(5 in 1..10) // true println(100 in 1..10) // false // range もオブジェクトなので変数に入れたりできる val r = 1..10 println(5 in r) // true // レンジからリストを得ることができる val list = r.toList() println(list) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] //sampleEnd } 条件分岐 if 条件分岐に用いる else を伴うことで「式」として用いることが可能 (変数に代入したりできる) fun main(args: Array) { //sampleStart val r = 1..10 if (5 in r) { println(\"5 is in range\") } // 式として用いて変数に代入することも可能 val n = 5 val result = if (n in r) { \"$n is in range\" } else { // 式として用いるときには else 必須 \"$n is not in range\" } println(result) // 5 is in range // else if で次々つなげることも可能 val age = 7 val fee = if (age > 12) { \"大人料金\" } else if (age >= 6) { \"小人料金\" } else { \"無料\" } println(\"$age 歳は $fee\") //sampleEnd } when switch 文のようなもの (なお Kotlin に switch はない) if と同じく、else を伴うことで「式」として用いることが可能 fun main(args: Array) { //sampleStart // オーソドックスな when の使い方 val n = 5 when (n) { 1 -> println(\"access\") 2, 3 -> println(\"company\") else -> println(\"com\") } //sampleEnd } fun main(args: Array) { //sampleStart // is を用いた型チェック // 値の代入もできる val n = 5 val type = when (n) { is Int -> \"$n is Int\" else -> \"$n is not Int\" } println(type) // 5 is Int //sampleEnd } fun main(args: Array) { //sampleStart // when のあとに値を伴わない書き方もできる val n = 5 when { // 以下、条件に一致したものがどれかひとつ実行される // 評価は上から順番に行われる n % 15 == 0 -> println(\"fizzbuzz\") n % 5 == 0 -> println(\"buzz\") n % 3 == 0 -> println(\"fizz\") else -> println(\"$n\") } //sampleEnd } fun main(args: Array) { //sampleStart // 定数以外も用いることができる val n = 5 when { n in 1..5 -> println(\"access\") // レンジ n > 5 -> println(\"company\") else -> println(\"com\") } //sampleEnd } ループ while fun main(args: Array) { //sampleStart // while による繰り返し var count1 = 0 while (count1 fun main(args: Array) { //sampleStart // do-while も使えます // 単なる while は繰り返し 0 回 (＝何もしない) もできるが、 // do-while の場合はまず do の中身を一度実行してから繰り返す var count2 = 0 do { // 繰り返したい処理 count2++ } while(count2 fun main(args: Array) { //sampleStart // 無限ループ while (true) { // 繰り返したい処理 println(\"押しちゃ駄目だ、押しちゃ駄目だ、押しちゃ駄目だ、押しちゃ駄目だ、押しちゃ駄目だ\") } //sampleEnd } for fun main(args: Array) { //sampleStart // for 文で繰り返し実行が可能なのは、 // イテレータを提供するオブジェクト (配列、リスト、レンジ、等) // Int の配列の場合 val ints = arrayOf(1, 2, 3) for (n in ints) { // 要素名 in イテレータオブジェクト println(n) // 1, 2, 3 が順番に出力される } //sampleEnd } fun main(args: Array) { //sampleStart // レンジを使う場合 var sum = 0 for (n in 1..10) { sum += n } println(sum) // 55 //sampleEnd } fun main(args: Array) { //sampleStart // リストを使う場合 var sum = 0 val list = (1..10).toList() for (n in list) { sum += n } println(sum) // 55 //sampleEnd } fun main(args: Array) { //sampleStart // 途中でループを抜けたり (break) // 次のループまでスキップしたり (continue) var count = 0 while (true) { count++ if (count == 10) { break // while ループを抜ける } if (count % 3 == 0) { println(\"3の倍数です！\") continue // 後ろの処理を行わずに次のループを開始する } println(count) } //sampleEnd } fun main(args: Array) { //sampleStart // ループが多重の場合は、 // どのループを抜けるかラベルで指定する outer@ for (i in 1..10) { // ← outer というラベルをつけたところ for (j in 1..10) { println(\"i=$i, j=$j\") if ((i+j) % 3 == 0) { println(\"Break!\") break@outer // 外側のループを抜ける // break のように何も指定しない場合、内側のループを抜ける } } } //sampleEnd } "},"function.html":{"url":"function.html","title":"関数","keywords":"","body":"関数 Kotlin の関数について記載します。 ゴール 以下について理解すること。 関数の定義の仕方、使い方 単一の式からなる関数 名前付き引き数、デフォルト引数 可変長引数 再帰呼び出し (末尾呼び出し最適化) ローカル関数 関数とは？ 何か（引数）を入れると、何らかの計算や処理を行って、入れた人に結果（戻り値）を返すもの。それ以上は省略。 色々な関数定義の仕方 基本形 //sampleStart // fun で始まる以下の形が基本の関数定義の仕方 // fun 関数名(引数リスト): 戻り値の型 fun add(a: Int, b: Int): Int { return a + b } //sampleEnd fun main(args: Array) { println(\"a=1, b=2, add(a, b)=${add(1, 2)}\") } 単一の式からなる関数の場合 //sampleStart // Int を 2 つとって足した数を返す関数 // 処理が一個しかない (式が一個) の場合はこんな風に書ける fun add(a: Int, b: Int): Int = a + b //sampleEnd fun main(args: Array) { println(\"a=1, b=2, add(a, b)=${add(1, 2)}\") } //sampleStart // Int を 2 つとって大きい方を返す関数 // if 文 1 個ということも可能 fun max(a: Int, b: Int): Int = if (a > b) a else b //sampleEnd fun main(args: Array) { println(\"a=1, b=2, max(a, b)=${max(1, 2)}\") } //sampleStart // Int を 2 つとって小さい方を返す関数 // 戻り値の型に型推論が効く fun min(a: Int, b: Int) = if (a ) { println(\"a=1, b=2, min(a, b)=${min(1, 2)}\") } 文を持つ //sampleStart // 文を扱うときはこう // Int を 2 つ引数に取って足し合わせた結果を返しつつ、画面に結果を出す関数 fun addWithPrint(a: Int, b: Int): Int { val result = a + b println(result) return result } //sampleEnd fun main(args: Array) { println(\"a=1, b=2\") addWithPrint(1, 2) } //sampleStart // Int の配列を引数にとって全部足し合わせたものを返す関数 fun sum(ints: Array): Int { var sum = 0 for (n in ints) { sum += n } return sum } //sampleEnd fun main(args: Array) { println(\"ints=[1, 2, 3, 4], sum(ints)=${sum(arrayOf(1, 2, 3, 4))}\") } 名前付き引数 fun main(args: Array) { //sampleStart // どの引数に値を渡すか、引数の名前を指定できる fun name(first: String, last: String) = println(\"$first $last\") // 名前を指定せずに呼び出すとき name(\"taro\", \"yamada\") // taro yamada // 名前を指定して呼び出すとき // 関数定義の順番に従う必要がなく、意味も分かりやすくなる場合もある name(last = \"yamada\", first = \"taro\") // taro yamada //sampleEnd } デフォルト引数 fun main(args: Array) { //sampleStart // デフォルトの値を指定してくことができる // 呼び出し時に値を指定しなかった場合はデフォルト値が使われる fun greet(name: String = \"anonymous\") { println(\"Hi, $name!\") } greet() // Hi, anonymous! greet(\"BOB\") // Hi, BOB! //sampleEnd } 可変長引数 fun main(args: Array) { //sampleStart // 引数に \"vararg\" をつけると可変長 (任意の個数、引数入力が可能) という意味になる fun sum(vararg ints: Int): Int { // 引数として任意の数の Int をとる var sum = 0 for (n in ints) { sum += n } return sum } // 呼び出し例 println(sum(1, 2, 3, 4)) // 10 // 配列を可変長引数として扱ってもらうこともできる var array = intArrayOf(1, 2, 3, 4, 5) // * をつけると配列を可変長引数として扱ってもらえる println(sum(*array)) // 15 //sampleEnd } "},"first_class_function.html":{"url":"first_class_function.html","title":"ちょっと特殊な関数","keywords":"","body":"ちょっと特殊な関数の使い方 第一級オブジェクトとしての関数について記載します。 ゴール 以下を理解すること。 関数もオブジェクトとして扱える 高階関数 ラムダ式、クロージャ インライン関数 オブジェクトとしての関数 関数もオブジェクトの一種 fun main(args: Array) { //sampleStart // 関数のオブジェクトを変数に代入する例 // 入力を二乗する関数 fun square(i: Int) = i * i // 関数のオブジェクトを取得するときは \"::\" をつける // 変数に代入できる val func = ::square println(square(5)) // 25 println(func(5)) // 25 (square を呼び出したのと同じ) //sampleEnd } 関数オブジェクトの型は？ 関数オブジェクトもオブジェクトの一種なので「型」がある fun main(args: Array) { //sampleStart // 入力を二乗する関数 fun square(i: Int) = i * i // 上の関数は「Int を引数にとって Int を返す関数」という型なので、 // 「Int を引数にとって Int を返す関数」型の変数に代入できる val func1: (Int) -> Int = ::square // 型があっていれば代入できる // 型があってないと代入できない // 以下の関数は (String) -> Unit という型 fun greet(name: String) = println(\"Hello $name!\") val func2: (Int) -> Int = ::greet // 型があっていないので代入できない (コンパイルエラー) println(func1(3)) func2(\"Tony\") //sampleEnd } 関数を引数として渡したり戻り値にしたり (高階関数) fun main(args: Array) { //sampleStart // 関数を引数にとる関数 // 第二引数には「Int を引数にとる関数」を指定する fun printWith(ints: List, printFunc: (Int) -> Unit) { for (i in ints) { printFunc(i) // 引数でもらった関数を呼び出す } } // 「Int を引数にとる関数」の例 fun myPrintFunc(i: Int) { if (i % 3 == 0) { println(\"3の倍数です!\") } else { println(i) } } // 関数オブジェクトを第二引数に指定して呼び出す printWith((1..10).toList(), ::myPrintFunc) //sampleEnd } fun main(args: Array) { //sampleStart // n 乗を返す関数を生成する関数 fun powerGen(n: Int): (Int) -> Long { fun power(num: Int): Long { var result: Long = 1 for (i in 1..n) { result *= num } return result } return ::power } // 入力を 5 乗する関数を生成 val fivePowerOf = powerGen(5) println(fivePowerOf(10)) // 100000 // 入力を 10 乗する関数を生成 val tenPowerOf = powerGen(10) println(tenPowerOf(2)) // 1024 //sampleEnd } 色々な関数の作り方 ラムダ式 関数を定義せずに関数オブジェクトを生成するコードをラムダ式と呼ぶ。 fun main(args: Array) { //sampleStart // 通常の関数オブジェクトを得る方法 // 関数定義 fun square(n: Int): Int { return n * n } // 定義された関数の名前に :: をつけて関数オブジェクトを得る println(::square) // fun square(kotlin.Int): kotlin.Int //sampleEnd } fun main(args: Array) { //sampleStart // 一方、ラムダ式を使う場合 // 関数の型 = { 引数リスト -> 関数の実装 } という形 val square: (Int) -> Int = { i: Int -> i * i } println(square) // (kotlin.Int) -> kotlin.Int println(square(3)) // 9 //sampleEnd } 型推論すると短く書ける fun main(args: Array) { //sampleStart // 「Int を引数にとって Int を返す」を型推論してもらい、 // 関数の型の記載を省略 val square = { i: Int -> i * i } println(square(3)) // 9 //sampleEnd } fun main(args: Array) { //sampleStart // または「Int を引数にとる」を型推論してもらい、 // 関数の実装における引数の型を省略 val square: (Int) -> Int = { i -> i * i } println(square(3)) // 9 //sampleEnd } fun main(args: Array) { //sampleStart // 両方省略するとiの型がわからないので、省略できない(コンパイルエラー) val square = { i -> i * i } println(square(3)) //sampleEnd } fun main(args: Array) { //sampleStart // 引数が一個の場合、「it」と書ける val square: (Int) -> Int = { it * it } println(square(3)) // 9 //sampleEnd } クロージャ コードを記述したときのスコープで変数が扱える (環境の捕捉、キャプチャを行う) 関数オブジェクトのこと。 //sampleStart // 呼び出すたびに数字を1つ増やす関数を返す fun genCounterFunc(): () -> Int { var count = 0 // ラムダ式の形で関数オブジェクトを返す // 以下の関数オブジェクトは「count 変数をキャプチャ」している return { count++ } } fun main(args: Array) { val func1 = genCounterFunc() val func2 = genCounterFunc() // func1 を呼び出すたびに、「func1 内の」変数が変更される println(func1()) // 0 println(func1()) // 1 println(func1()) // 2 // func2 を呼び出すたびに、「func2 内の」変数が変更される println(func2()) // 0 println(func2()) // 1 println(func2()) // 2 } //sampleEnd インライン関数 関数がインライン展開 (関数呼び出しの場所に関数定義が挿入されるイメージ) される仕組み。 高階関数の扱いは呼び出しのコストが高いが、インライン関数でより効率よくできる場合がある。 fun main(args: Array) { //sampleStart // インライン展開なし fun log(debug: Boolean, message: () -> String) { if (debug) { println(message()) } } log(true, { \"log message\" }) // 表示される log(false, { \"log message\" }) // 表示されない //sampleEnd } fun main(args: Array) { //sampleStart // もしくはlogの{}をカッコの外に出して、こう書ける fun log(debug: Boolean, message: () -> String) { if (debug) { println(message()) } } log(true) { \"log message\" // 表示される } log(false) { \"log message\" // 表示されない } //sampleEnd } // インライン展開する inline fun log(debug: Boolean, message: () -> String) { if (debug) { println(message()) } } fun main(args: Array) { log(true) { \"log message\" // 表示される } log(false) { \"log message\" // 表示されない } } fun main(args: Array) { //sampleStart // 上述の main 関数は、以下と概ね同義になる // debug が true でないときは、関数呼び出しまで到達しないコードになる if (true) { println(\"log message\") // 表示される } if (false) { println(\"log message\") // 表示されない } //sampleEnd } // 非ローカルリターン // inline 展開を利用して、外側の関数を抜けるテク // 入力した文字列 (str) の全要素に対して何か (f) する関数 inline fun forEach(str: String, f: (Char) -> Unit) { for (c in str) { f(c) } } // 入力した文字列 (str) に数字が含まれているかどうかを返す関数 fun containsDigit(str: String): Boolean { forEach(str) { if (it.isDigit()) { // forEach が inline 展開されるため、 // この return はラムダ式 (fun forEach の f(c) 部分) じゃなくて // fun containsDigit を抜ける。 return true } } return false } fun main(args: Array) { println(containsDigit(\"ACCESS\")) // false println(containsDigit(\"C0MPANY\")) // true } inline fun forEach(str: String, f: (Char) -> Unit) { for (c in str) { f(c) } } fun main(args: Array) { //sampleStart // inline だが非ローカルリターンしたくない場合は、 // ラベルへのリターンを利用する // 入力した文字列 (str) に数字が含まれているかどうかを返す関数 fun containsDigit(str: String): Boolean { var result = false forEach(str) loop@ { if (it.isDigit()) { result = true return@loop // forEach を抜ける // return@forEach という書き方も可能 } } return result } println(containsDigit(\"ACCESS\")) // false println(containsDigit(\"C0MPANY\")) // true //sampleEnd } 無名関数 ラムダ式のように関数オブジェクトを得るもうひとつの方法 inline 展開はできない fun main(args: Array) { //sampleStart // ラムダ式 (再掲) val square: (Int) -> Int = { i: Int -> i * i } println(square(3)) // 9 //sampleEnd } fun main(args: Array) { //sampleStart // 無名関数 // 上記のラムダ式にあたる部分に関数を書くイメージ val square: (Int) -> Int = fun(i: Int): Int { return i * i // ラムダ式と違って要 return 文 } println(square(3)) // 9 //sampleEnd } fun main(args: Array) { //sampleStart // 無名関数 省略版 val square: (Int) -> Int = fun(i : Int) = i * i println(square(3)) // 9 //sampleEnd } "},"class.html":{"url":"class.html","title":"クラス","keywords":"","body":"クラス クラスについて記載します。 ゴール 以下について理解すること。 オブジェクト指向 基本的なクラスの作り方、使い方 メソッド プロパティ コンストラクタとイニシャライザ エクステンション オブジェクト指向とクラス 突然出てきた用語…まず「オブジェクト」って？ 物や事柄すべてのこと。人間とか、木とかもオブジェクト プログラミング的には、データと関数の集合体 「クラス」って？ オブジェクトの設計図 なぜクラスが要るの？ 同じオブジェクトを毎回ゼロから組み立てるのは大変だから オブジェクト指向って？ オブジェクトをクラスやインスタンスで表現し、効率よくアプリ全体を組み立てようって考え方 インスタンスについては、すぐ後で説明する 継承、インタフェース、カプセル化の理解も大事だが、ここでは省略 以前の研修で使われてた資料（参考までに） …と、これだけでは伝わらないと思うので、具体例へ 家計簿アプリを作る場合、どうする？ 機能が多いので、収支履歴機能、残高機能、口座機能、と機能別に設計するのが望ましい 収支履歴クラス、残高クラス、口座クラス、さらにユーザー情報クラスと分割 それぞれに必要なデータ(変数)と処理(関数)を持たせる。データだけのクラス、処理だけのクラスもあり得る クラスは、1つの機能を持ったプチOS、とイメージしてもよい クラスは設計書のようなものであり、それ自体はデータを保持できない。しかし画面を表示してる間はデータを保持する必要がある そこでアプリは、クラスの実体をコンピューターメモリ上に生産し、データ保持可能にする。その生産物をインスタンスと呼ぶ オブジェクトと呼ぶこともある アプリは、必要なインスタンスを参照しながら、家計簿として振る舞う 例えば、残高と収支履歴のインスタンスを使って今月の家計簿を表示するなど クラスの作り方と使い方 クラスを定義する 以下、クラスにプロパティとメソッドを持たせる例。 fun main(args: Array) { //sampleStart // ヒトを表すクラス class Person { // プロパティ (名前) var name: String = \"\" // プロパティ (年齢、カスタムセッター付き) var age: Int = 0 set(i) = if (i = 20) { return true } return false } } // クラスの使い方 (インスタンス化) // クラスからオブジェクトを生成することをインスタンス化という // Person クラスのインスタンス化 val pankona = Person() // プロパティに値をセット pankona.name = \"yosuke akatsuka\" pankona.age = 37 // プロパティの値を参照する println(pankona.name) // yosuke akatsuka println(pankona.age) // 37 println(pankona.nameLength) // 15 // メソッドの呼び出し if (pankona.isAdult()) { println(\"pankona belongs to adult team\") } else { println(\"pankona belongs to young team\") } //sampleEnd } バッキングフィールド 値を実際に置かれている領域のこと カスタムゲッターを置くとバッキングフィールドはなくなる プロパティと呼んでいるのは、バッキングフィールドにアクセスするための窓口 // ヒトを表すクラス (再掲) fun main(args: Array) { //sampleStart class Person { // これらのプロパティはバッキングフィールドを持つ var name: String = \"\" var age: Int = 0 // カスタムゲッターを設定 // 本プロパティにはバッキングフィールドがない val nameLength: Int get() = name.length } val pankona = Person() pankona.name = \"yosuke akatsuka\" pankona.age = 37 println(pankona.name) println(pankona.age) println(pankona.nameLength) //sampleEnd } lateinit バッキングフィールドをもつプロパティは、宣言と同時に値を入れる (初期化) が必須 ただ、それだと困る場合があるので初期化を遅らせる lateinit という仕組みがある lateinit は var にのみつけられる lateinit をつけていて値の初期化を行う前にプロパティにアクセスすると kotlin.UninitializedPropertyAccessException という例外がスローされる Android アプリの開発においては割と多様される (諸説ある) fun main(args: Array) { //sampleStart // コンパイルが通らないヒトを表すクラス class Person { // これらのプロパティはバッキングフィールドを持つ // そのため、以下のように宣言時に初期化をしないとコンパイルエラーになる var name: String // コンパイルエラー！ var age: Int // コンパイルエラー！ } val pankona = Person() pankona.name = \"yosuke akatsuka\" pankona.age = 37 println(pankona.name) println(pankona.age) //sampleEnd } fun main(args: Array) { //sampleStart // lateinit を使ってコンパイルが通るヒトを表すクラス class Person { // lateinit を使うと、宣言時に初期化しなくて良い lateinit var name: String } val p = Person() // p.name は未初期化なので、このまま触ると // kotlin.UninitializedPropertyAccessException が発生 // p.name を初期化して例外を出なくしよう！ println(p.name) //sampleEnd } プリミティブ型 2つ上の例 // コンパイルが通らないヒトを表すクラス で、 age は lateinit を使うとコンパイルエラーになる。これは Int がプリミティブ型で、 null を代入できないから Kotlinでは、Double, Float, Long, Int, Short, Byte, Boolean, Char がプリミティブ型 age の型を Int? にすると、ラッパークラス java.lang.Integer にボクシングされ、プリミティブ型ではなくなる でも、Nullableな型には lateinit を使う必要がないので、やはりコンパイルエラーとなる lateinit を使わず、 var age: Int = 0 か var age: Int? = null でコンパイルできる 結論は、プリミティブ型には lateinit を使わない ちなみに、Javaだと List はできないが、Kotlinはプリミティブ型もオブジェクトとして振る舞うので、 List ができる this クラス内で別のプロパティ、メソッドにアクセスする際に使える 省略しても良い fun main(args: Array) { //sampleStart // ヒトを表すクラス (再掲) class Person { var name: String = \"\" var age: Int = 0 val nameLength: Int get() = this.name.length // ← this をつけて name を参照 } val pankona = Person() pankona.name = \"yosuke akatsuka\" pankona.age = 37 println(pankona.name) println(pankona.age) println(pankona.nameLength) //sampleEnd } コンストラクタ インスタンスを生成する際に、各プロパティの初期化を補助する仕組み fun main(args: Array) { //sampleStart // ヒトを表すクラス // コンストラクタの書き方は従来はこう。 class Person constructor(n: String, a: Int) { val name: String = n val age: Int = a } // コンストラクタを用いたインスタンスの初期化 val p = Person(\"yosuke akatsuka\", 37) println(p.name) // yosuke akatsuka println(p.age) // 37 //sampleEnd } fun main(args: Array) { //sampleStart // ヒトを表すクラス // コンストラクタに val、var を伴うことで、そのままプロパティとして扱うこともできる。 class Person constructor(val name: String, val age: Int) // 前の例と同じように使える val p = Person(\"yosuke akatsuka\", 37) println(p.name) // yosuke akatsuka println(p.age) // 37 //sampleEnd } fun main(args: Array) { //sampleStart // ヒトを表すクラス // ちなみに、constructor の文字は省略が可能 (先述のものと意味は同じ) class Person (val name: String, val age: Int) val p = Person(\"yosuke akatsuka\", 37) println(p.name) // yosuke akatsuka println(p.age) // 37 //sampleEnd } コンストラクタの色々 クラス名の横にコンストラクタを書く場合、それを「primary constructor」と呼ぶ。 クラスの中にふたつめ以上のコンストラクタを書く場合、それ (ら) を「secondary constructor」と呼ぶ。 primary constructor がある場合、secondary constructor は primary constructor を呼び出す必要がある。 primary constructor に処理は書けないが、secondary constructor には処理が書ける。 primary constructor で処理が書きたい場合は、後述のイニシャライザを用いる。 fun main(args: Array) { //sampleStart // ヒトを表すクラス // 別引数を持つ2つ目のコンストラクタを定義することもできる class Person (val name: String, val age: Int) { // 引数なしのコンストラクタを定義 // this を使って ↑ のコンストラクタを呼び出す constructor() : this(\"anonymous\", 999) { println(\"this is secondary constructor!\") } } val p = Person(\"yosuke akatsuka\", 37) println(p.name) // yosuke akatsuka println(p.age) // 37 val pDefault = Person() println(pDefault.name) // anonymous println(pDefault.age) // 999 //sampleEnd } イニシャライザ primary constructor が解決された後に呼び出される部分 constructor では足りない初期化処理を行う場合はここでやる エラー処理 (例外を発生させる) のであればここで fun main(args: Array) { //sampleStart // ヒトを表すクラス class Person(val name: String, val age: Int) { init { // 条件を満たさない場合は例外をスロー // java.lang.IllegalArgumentException: Failed requirement. require(age >= 0) } } val p = Person(\"pankona\", -10) // 例外発生 println(p.name) println(p.age) //sampleEnd } クラスの拡張 拡張関数 既存のクラスにメソッドを追加する仕組み fun main(args: Array) { //sampleStart // 文字列の長さを取得する関数を普通に作ると fun strlen(str: String) = str.length println(strlen(\"hogehoge\")) // 8 //sampleEnd } //sampleStart // 文字列の長さを返す関数 size を String クラスに生やす // オブジェクトへの参照を得るには this が使える (省略可) fun String.size() = this.length fun main(args: Array) { println(\"hogehoge\".size()) // 8 } //sampleEnd 拡張プロパティ 既存のクラスの拡張はメソッドのみならず、プロパティの追加もできる。 ただしバッキングフィールドは追加できない。 //sampleStart // 文字列の長さを返すプロパティを生やす val String.size: Int get() = this.length fun main(args: Array) { println(\"hogehoge\".size) // 8 } //sampleEnd データクラス data class の定義 クラスを単にデータの塊として表現したいときに用いる 通常のクラス定義の頭に data をつける val String.size: Int get() = this.length fun main(args: Array) { //sampleStart // ヒトクラス (data が頭にくっついている) data class Person(val name: String, val age: Int) println(\"hogehoge\".size) // 8 //sampleEnd } data class の特徴 fun main(args: Array) { //sampleStart // ヒトクラス data class Person(val name: String, val age: Int) // 同じ名前と年齢を与える val p1 = Person(\"access\", 37) val p2 = Person(\"access\", 37) // 以下は true になる p1 == p2 // true // println に渡すといい感じに表示される println(p1) // Person(name = access, age = 37) // copy 等の便利メソッドが生える val p3 = p1.copy() println(p3) // Person(name = access, age = 37) // copy は一部のプロパティだけついでに変更したりもできる val p4 = p1.copy(age = 17) println(p4) // Person(name = access, age = 17) //sampleEnd } data class を使うと嬉しい場面 通常のクラスを用いると、上記の比較は p1 と p2 はイコール判定されない copy 等の便利メソッドを自動的に生やしてくれる 以下は通常のクラスとの違い fun main(args: Array) { //sampleStart // ヒトクラス class Person(val name: String, val age: Int) // 同じ名前と年齢を与える val p1 = Person(\"access\", 37) val p2 = Person(\"access\", 37) // p1 と p2 は、「値は同じかもしれないが違うオブジェクト」なので // 下記の評価結果は false になる p1 == p2 // false // println に渡しても内容は表示されない println(p1) // Line_5$Person@3bd42f5b // copy メソッドがないのでコピーできない val p3 = p1.copy() // メソッドがないのでエラー //sampleEnd } "},"inherit_abstract.html":{"url":"inherit_abstract.html","title":"継承・抽象クラス","keywords":"","body":"継承・抽象クラス クラスの継承・抽象クラスについて記載します。 ゴール 以下を理解していること。 継承の振る舞い 抽象クラスの使い方、抽象クラスの存在意義 オーバーライドの仕方 (open) 可視性 (public、internal、private、protected) 継承 継承とは ざっくり言えば「あるクラスの性質を別のクラスに引き継ぐ」ための仕組み クラスを継承 fun main(args: Array) { //sampleStart // ヒトクラス class Person(val name: String) { // 名前の長さを返すプロパティ val nameLength: Int get() = name.length // どこで生まれたかを返すメソッド fun bornFrom() = \"unknown\" } val p = Person(\"Tonio Nagauzzi\") println(p.name) // Tonio Nagauzzi println(p.nameLength) // 14 println(p.bornFrom()) // unknown //sampleEnd } ヒトクラスを継承してみる このままでは継承はできなくて、open をつける必要がある 継承すると、メソッド一式とプロパティ一式を継承先は引き継ぐ fun main(args: Array) { //sampleStart // open がついて継承可能になったヒトクラス open class Person(val name: String) { // 名前の長さを返すプロパティ val nameLength: Int get() = name.length // どこで生まれたかを返すメソッド fun bornFrom() = \"unknown\" } // ヒトクラスを継承して男クラスと女クラスを作る // (コンストラクタに val がついてない点に注意) class Man(name: String) : Person(name) class Woman(name: String) : Person(name) // ヒトクラスを使う val p = Person(\"p\") println(p.nameLength) // 1 println(p.bornFrom()) // unknown // 継承した各クラスを使う // 各々、Person から引き継いだプロパティが利用できる val m = Man(\"bob\") println(m.name) // bob println(m.nameLength) // 3 println(m.bornFrom()) // unknown val w = Woman(\"alice\") println(w.name) // alice println(w.nameLength) // 5 println(w.bornFrom()) // unknown //sampleEnd } メンバのオーバーライド プロパティ、メソッドを継承先で上書きする仕組み オーバーライドするためには、オーバーライドするプロパティ、メソッドに open をつける fun main(args: Array) { //sampleStart // open がついて継承可能になったヒトクラス open class Person(val name: String) { // open がついて継承が可能になった名前の長さを返すプロパティ open val nameLength: Int get() = name.length // open がついて継承が可能になったどこで生まれたかを返すメソッド open fun bornFrom() = \"unknown\" } // ヒトクラスを継承して男クラスと女クラスを作る class Man(name: String) : Person(name) { // nameLength を Man 用の振る舞いにオーバーライド override val nameLength: Int get() { print(\"$name (man) \") // 名前の後ろに (man) を表示するようにした return name.length } // bornFrom を Man 用の振る舞いにオーバーライド override fun bornFrom() = \"mud\" // 土から生まれた fun doShibakari() { println(\"山へ芝刈りに\") } } class Woman(name: String) : Person(name) { // nameLength を Woman 用の振る舞いにオーバーライド override val nameLength: Int get() { print(\"$name (woman) \") // 名前の後ろに (woman) を表示するようにした return name.length } // bornFrom を Woman 用の振る舞いにオーバーライド override fun bornFrom() = \"rib\" // 肋骨から生まれた fun doSentaku() { println(\"川へ洗濯に\") } } // ヒトクラスを使う val p = Person(\"p\") println(p.nameLength) // 1 println(p.bornFrom()) // unknown // 継承した各クラスを使う // 各々、オーバーライドしたメソッドとプロパティを使ってみる val m = Man(\"bob\") println(m.name) // bob println(m.nameLength) // bob (man) 3 println(m.bornFrom()) // mud // Man 専用メソッド m.doShibakari() // 山へ芝刈りに val w = Woman(\"alice\") println(w.name) // alice println(w.nameLength) // alice (woman) 5 println(w.bornFrom()) // rib // Woman 専用メソッド w.doSentaku() // 川へ洗濯に //sampleEnd } スーパータイプとサブタイプ Man と Woman は継承元のクラスである Person として扱うことができる fun main(args: Array) { open class Person(val name: String) { // open がついて継承が可能になった名前の長さを返すプロパティ open val nameLength: Int get() = name.length // open がついて継承が可能になったどこで生まれたかを返すメソッド open fun bornFrom() = \"unknown\" } class Man(name: String) : Person(name) { // nameLength を Man 用の振る舞いにオーバーライド override val nameLength: Int get() { print(\"$name (man) \") // 名前の後ろに (man) を表示するようにした return name.length } // bornFrom を Man 用の振る舞いにオーバーライド override fun bornFrom() = \"mud\" // 土から生まれた fun doShibakari() { println(\"山へ芝刈りに\") } } class Woman(name: String) : Person(name) { // nameLength を Woman 用の振る舞いにオーバーライド override val nameLength: Int get() { print(\"$name (woman) \") // 名前の後ろに (woman) を表示するようにした return name.length } // bornFrom を Woman 用の振る舞いにオーバーライド override fun bornFrom() = \"rib\" // 肋骨から生まれた fun doSentaku() { println(\"川へ洗濯に\") } } //sampleStart // 継承先 (サブタイプ) を、 // 継承元 (スーパータイプ) の変数に入れる val m: Person = Man(\"bob\") // Person (継承元) が持っているプロパティ、メソッドにはアクセスできる // 実装は Man (継承先) に従う println(m.name) // bob println(m.bornFrom()) // mud m.doShibakari() // m はあくまで Person なので doShibakari は使えない (コンパイルエラー) //sampleEnd } 最後の行は (m as Man).doShibakari() とダウンキャストすればコンパイルできる 抽象クラス 抽象クラスを使うと嬉しい場面 サブクラスにオーバーライドを強制する仕組み abstract をつけたメソッドやプロパティは、サブクラスで必ずオーバーライドする必要がある fun main(args: Array) { abstract class Person() { // どこから生まれたかメソッドを抽象メソッドにする。 // abstract の場合、スーパークラスでは実装を書かなくてよい。 // なお、abstract がついてる場合はオーバーライドすることが前提なので、 // open もつけなくて良い abstract fun bornFrom(): String } class Man() : Person() { // スーパークラスでは abstract がついているメソッドなので、 // サブクラスでオーバーライドしないとコンパイルエラーになる override fun bornFrom() = \"mud\" } class Woman() : Person() { // こっちもオーバーライドする override fun bornFrom() = \"rib\" } // 使い方 val p: Person = Person() // Person は abstract なのでインスタンス化はできない val m: Person = Man() // これは OK val w: Person = Woman() // これも OK println(m.bornFrom()) // mud println(w.bornFrom()) // rib } 可視性 この章ではブラウザ上でのコード実行はできません。実行機能はパッケージ分けに対応していないから パッケージ パッケージ (package) とはクラスを分類する仕組み。基本的に全てのクラスはどこかのパッケージに属している パッケージを指定しない場合、デフォルトのパッケージ (名前はない) に属することになる //sampleStart // パッケージを宣言。車パッケージとする package io.access.car // 以下、本ファイルに書くクラス、関数は io.access.car パッケージに属する class Car(val name: String) fun greet() { // ... } //sampleEnd fun main(args: Array) { greet() } 他のパッケージから io.access.car パッケージを参照する場合、import 文を用いて利用したいパッケージをインポートする必要がある // Begin Car.kt package io.access.car class Car(val name: String) // End Car.kt // Begin Store.kt //sampleStart // 上記の車パッケージとは別のパッケージ。店パッケージとする package io.access.store // car をインポートすると Car を使うことができる // 以下の書き方をすると io.access.car パッケージに含まれるクラス全てがインポートされる import io.access.car.* class Store { val car = Car() } //sampleEnd fun main(args: Array) { Store(car: Car(name = \"Fairlady\")) } // End Store.kt インポートしたクラスに as を使って別名をつけることもできる クラス名が別のパッケージに含まれるクラスと重複したときなどに有用 クラス名が長い場合に短くしたりという使い方も // Begin Car.kt package io.access.car class Car(val name: String) // End Car.kt // Begin Store.kt //sampleStart package io.access.store // as を使ってインポートしたクラスに別名をつける import io.access.car.Car as MyCar class Store { // MyCar として利用できる val car = MyCar() } //sampleEnd fun main(args: Array) { Store(car: MyCar(name = \"Fairlady\")) } // End Store.kt トップレベルの宣言における可視性の指定 宣言したクラスについて、他のパッケージ、他のクラスからどの程度参照可能にするかどうかを指定できる トップレベルでの宣言 (クラスや関数の外での宣言を指す) に対しては、public、internal、private が選択できる 何も記載しなかった場合、public 扱いになる // Begin Sample.kt //sampleStart // サンプルパッケージがあったとして package sample // 以下のように関数が宣言されていたとする // public はパッケージ外からもファイル外からもアクセス可能 (デフォルト) public fun publicFunc() { println(\"public!\") } // private は同一ファイル内からのみアクセス可能 private fun privateFunc() { println(\"private!\") } // internal は同一モジュールからのみアクセス可能 // モジュールというのは Maven、Gradle のプロジェクト単位 // 外部には公開したくないが内側では広く使いたい、みたいなときに用いる internal fun internalFunc() { println(\"internal!\") } //sampleEnd // End Sample.kt // Begin Main.kt import sample fun main(args: Array) { publicFunc() privateFunc() internalFunc() } // End Main.kt // Begin Sample.kt package sample public fun publicFunc() { println(\"public!\") } private fun privateFunc() { println(\"private!\") } internal fun internalFunc() { println(\"internal!\") } // End Sample.kt // Begin Main.kt //sampleStart import sample fun main(args: Array) { publicFunc() // コンパイル OK privateFunc() // コンパイル NG internalFunc() // 場合による } //sampleEnd // End Main.kt クラス内部の宣言の場合 トップレベルの宣言時に使える 3 種に加えて、protected を使うことができる private は同一クラス内からのみアクセス可能 protected は private に近いが、サブクラスからもアクセス可能 //sampleStart // スーパークラス open class Person { private fun privateMethod() {} protected fun protectedMethod() {} internal fun internalMethod() {} public fun publicMethod() {} } // サブクラス class Woman: Person() { fun function() { privateMethod() // コンパイル NG publicMethod() // コンパイル OK internalMethod() // 場合による protectedMethod() // コンパイル OK } } // 関係ないクラス class Foot { fun function() { val p = Person() p.protectedMethod() // コンパイル NG p.publicMethod() // コンパイル OK p.internalMethod() // 場合による } } //sampleEnd fun main(args: Array) { Foot().function() } "},"interface.html":{"url":"interface.html","title":"インターフェース","keywords":"","body":"インターフェース インターフェースについて記載します。 ゴール 以下を理解していること。 基本的なインターフェースの作り方、使い方 プロパティ interface をオーバーライドしてクラスを作る デリゲーション インターフェース インターフェースとは？ abstract なクラスに近いが、状態 (バッキングフィールド) を持つことができないクラス 具象（クラス）に対する抽象（インターフェース）として、上位の設計思想を守るため使われることが多い プロパティ、メソッドを持たせることができるが、いずれも abstract になる コンストラクタを持たせることはできない 定義の仕方 interface と書いて宣言する 実装の仕方 class を作ってインターフェースを継承する abstract なものをひととおりオーバーライドする (interface を実装する、と呼ぶ) //sampleStart // Greeter (挨拶するひと) インターフェース interface Greeter { // プロパティ、メソッドを持たせられるが、いずれも abstract // 強制的に abstract になるので、abstract は書かないでも良い (書いても良いが冗長) // また、メンバは全て public 扱いになる val language: String fun sayHello(target: String) } // Greeter interface を実装する EnglishGreeter クラス class EnglishGreeter : Greeter { // val language と fun sayHello を // オーバーライドしないとコンパイルが通らない override val language = \"English\" override fun sayHello(target: String) { println(\"Hello! $target!\") } } //sampleEnd fun main(args: Array) { EnglishGreeter().sayHello(\"Everyone\") } ちなみに、クラスの継承はひとつまでなのに対し、インターフェースは複数継承することができる //sampleStart // インターフェースがふたつ以上あったとして... interface Cookie { fun whiteDay() } interface Chocolate { fun valentinesDay() } // クラスは複数のインターフェースを継承して実装することができる class Sweet : Cookie, Chocolate { // Cookie、Chocolate に含まれるメンバを // 全てオーバーライドする (実装する) 必要がある override fun whiteDay() {} override fun valentinesDay() {} } //sampleEnd fun main(args: Array) { val sweet = Sweet() sweet.valentinesDay() sweet.whiteDay() } デフォルト実装 インターフェースに含まれるメソッドを実装しておくことができる 継承した側でオーバーライドしない場合、デフォルト実装が使われる interface Greeter { // デフォルト実装をもったメソッド fun sayHello(target: String) { println(\"Hello $target!\") } } class EnglishGreeter : Greeter { // sayHello の実装を省略 } fun main(args: Array) { val g: Greeter = EnglishGreeter() g.sayHello(\"takeshi\") // Hello takeshi! } クラスデリゲーション 継承の問題点として、以下のようなものがある こじらせるとクラスがどんどん大きくなってしまう (共通機能をつめこみたくなる) スーパークラスの変更はただちにサブクラスに影響する (変更の影響範囲を小さくできない) 継承せずに別クラスに処理を委譲するやり方をデリゲーションと呼ぶ 継承と委譲それぞれの実装例を見てみよう。 // 継承するパターン // インターフェースの定義 interface Greeter { fun sayHello() fun sayHello(target: String) } // 英語で挨拶クラス open class EnglishGreeter : Greeter { override fun sayHello() { // 名前を省略したら anonymous さんに挨拶する sayHello(\"anonymous\") } override fun sayHello(target: String) { println(\"Hello, $target!\") } } // 名前を指定されたときはすごい挨拶をする // 英語で挨拶クラスを継承して拡張した class EnglishGreeterGreatAgain : EnglishGreeter() { override fun sayHello(target: String) { // スーパークラスの実装を呼び出す super.sayHello(\"$target great again!\") // Hello $target great again! } } fun main(args: Array) { val g = EnglishGreeterGreatAgain() g.sayHello(\"America\") // Hello America great again! g.sayHello(\"Japan\") // Hello Japan great again! g.sayHello(\"Germany\") // Hello Germany great again! g.sayHello() // Hello anonymous great again ← ！？ } 継承で一部分だけ拡張したつもりでいたが、結局のところはスーパークラスの実装への依存があり、制御が難しい場合がある スーパークラスをいじれれば良いが、そうでない場合は思い通りにできない場合も // 委譲するパターン // インターフェースの定義 interface Greeter { fun sayHello() fun sayHello(target: String) } // 英語で挨拶クラス open class EnglishGreeter : Greeter { override fun sayHello() { // 名前を省略したら anonymous さんに挨拶する sayHello(\"anonymous\") } override fun sayHello(target: String) { println(\"Hello, $target!\") } } // 名前を指定されたときはすごい挨拶をする // 英語で挨拶クラスを委譲して拡張した class EnglishGreeterGreatAgain : Greeter { // 継承ではなく、メンバとして値を持つ private val g: Greeter = EnglishGreeter() override fun sayHello() { // 単にメソッドを呼び出す g.sayHello() } override fun sayHello(target: String) { // 拡張してメソッドを呼び出す g.sayHello(\"$target great again!\") } } fun main(args: Array) { val g = EnglishGreeterGreatAgain() g.sayHello(\"America\") // Hello America great again! g.sayHello(\"Japan\") // Hello Japan great again! g.sayHello(\"Germany\") // Hello Germany great again! g.sayHello() // Hello anonymous! } 通常、委譲するほうが継承するよりもコードは多くなる傾向がある 上の例の場合、sayHello() も sayHello(target: String) も要実装になっている ところが、Kotlin の場合、委譲してもコード量を増やさない技が備わっている // インターフェースの定義 interface Greeter { fun sayHello() fun sayHello(target: String) } // 英語で挨拶クラス open class EnglishGreeter : Greeter { override fun sayHello() { // 名前を省略したら anonymous さんに挨拶する sayHello(\"anonymous\") } override fun sayHello(target: String) { println(\"Hello, $target!\") } } // コンストラクタで Greeter をとりつつ、\"Greeter by greeter\" と指定して継承 // override してない部分は greeter に委譲するという意味になる class EnglishGreeterGreatAgain(private val greeter: Greeter): Greeter by greeter { // override fun sayHello() は実装しない (= greeter に委譲) // 拡張したいところだけ override override fun sayHello(target: String) { greeter.sayHello(\"$target great again!\") } } fun main(args: Array) { val eg = EnglishGreeter() val g = EnglishGreeterGreatAgain(eg) g.sayHello(\"America\") // Hello America great again! g.sayHello(\"Japan\") // Hello Japan great again! g.sayHello(\"Germany\") // Hello Germany great again! g.sayHello() // Hello anonymous! } インターフェースがあると嬉しい場面 インターフェースを実装したクラスは、インターフェースのほうの「型」として扱うことができる // Greeter インターフェース interface Greeter { fun sayHello(target: String) } // Greeter インターフェースを受け取って呼び出すだけの関数 fun greeting(g: Greeter, target: String) { g.sayHello(target) } // 日本語で挨拶 class JapaneseGreeter : Greeter { override fun sayHello(target: String) { println(\"こんにちは、$target さん！\") } } // 英語で挨拶 class EnglishGreeter : Greeter { override fun sayHello(target: String) { println(\"Hello, $target!\") } } // ドイツ語で挨拶 class GermanyGreeter : Greeter { override fun sayHello(target: String) { println(\"Guten morgen, $target!\") } } fun main(args: Array) { // greeting 関数は Greeter インターフェースを実装したクラスを // 引数にとるので、以下はいずれも有効な書き方 greeting(JapaneseGreeter(), \"world\") // こんにちは、world さん！ greeting(EnglishGreeter(), \"world\") // Hello, world! greeting(GermanyGreeter(), \"world\") // Guten morgen, world! } 実装の中身を入れ替えたいときに便利 テスト用に常に OK を返すだけのクラスにしたい SQLite を使っていたが Postgres に変更したい などなど "},"generics.html":{"url":"generics.html","title":"ジェネリクス","keywords":"","body":"ジェネリクス ジェネリクスについて記載します。 ゴール 以下を理解していること。 ジェネリクスの使い方、使いどころ ジェネリック関数 ジェネリック制約 ジェネリクス ジェネリクスとは 利用する型を仮で書いておいて、実際の型はあとから指定するという記述方法。 任意の型をパラメータにしたいときはどのような書き方ができるか？ // value というプロパティを持った Container というクラスを仮定 // value の型は Any class Container(val value: Any) fun main(args: Array) { // 値を入れるとき val intContainer: Container = Container(10) // OK val strContainer: Container = Container(\"hello!\") // OK // 値を取り出すとき // as ◯◯ をつけてキャストする必要がある val i = intContainer.value as Int // OK val s = strContainer.value as String // OK // ところがキャストは失敗する可能性がある val i2 = intContainer.value as String // 実行時に ClassCastException の例外を吐かれる } 上記の例の場合、ClassCastException が出ないように作るのはプログラマの責任 ジェネリクスを使うと、コンパイル時に妥当かチェックしてもらえる // any を使わず、ジェネリクスを使った場合 // value の型は として仮置きしている class Container(val value: T) fun main(args: Array) { // 値を入れるとき val intContainer: Container = Container(10) // 値を取り出すときにキャスト不要 // キャスト不要なので ClassCastException も起こらない val i: Int = intContainer.value // 使い方が違っていればコンパイル時にエラーになる val s: String = intContainer.value // コンパイルエラー } ジェネリック関数 ジェネリクスは関数、メソッド、プロパティにも適用できる // data クラスにしてみる data class Container(val value: T) // 関数にジェネリクスを用いる場合 fun box(value: T): Container { return Container(value) } val T.string: String get() = toString() fun main(args: Array) { val container = box(100) println(container.string) // Container(value=100) } ジェネリック制約 ジェネリクスでは任意の型を扱うことができるが、「何らかのクラスのサブクラスだけに制限したい」という制限も可能 interface IFA interface IFB class A() class B() // IFA interface を継承した T に限る fun main(args: Array) { A() // OK A() // OK B() // OK B() // error: type argument is not within its bounds: should be subtype of 'IFA' } where を使って制約を複数にすることもできる interface IFA interface IFB interface IFC: IFA, IFB // IFC は IFA、IFB を継承 class A where T : IFA, T: IFB // T は IFA のサブクラスかつ IFB のサブクラスに限る fun main(args: Array) { A() // error: type argument is not within its bounds: should be subtype of 'IFB' A() // error: type argument is not within its bounds: should be subtype of 'IFA' A() // OK } 以下については記載を省略 変位指定 スター投影 具象型 "},"null_safe.html":{"url":"null_safe.html","title":"Null安全","keywords":"","body":"Null安全 Null 安全について記載します。 ゴール 以下について理解していること。 Null 安全が必要な背景 スマートキャスト 安全呼び出し演算子 (?) 強制呼び出し演算子 (!!) エルビス演算子 (?:) 安全キャスト null って何よ null そのものの意味は、\"空\" とか \"無\" とか。ドイツ語らしい。 変数に null を入れると、その変数はどこも参照していない (null を参照している) 状態になる null を参照しているオブジェクトのメソッド呼び出しは例外 (NullPointerException) を発生させる NullPointerException になるのが期待動作ということは基本的になく、概してプログラミングのミスで発生する Java のコードで NullPointerException が出る例は以下のような場合。 以下、Java のコード例には「Java」と記載 (特に注釈がなければ Kotlin のコード例) Java String s = null; // null を入れる s.toUpperCase(); // NullPointerException 発生 従来の null との戦い NullPointerException と null チェック NullPointerException が起きないように、変数を参照する前に変数が null でないかを確認する必要が生じることがしばしばある 実はきっちり対処しようとするとそれなりに手間 Java // 上述のコード例における NullPointerException を回避する String s = null; if (s != null) { // null じゃないことを確認する s.toUpperCase(); } ところが、 Java の言語仕様上、変数は基本的に全て null になりうる その点だけ捉えると全ての変数について使う前に null チェックするのが妥当か…？ 文脈上、絶対に null でないことが確定しているような場合はチェックするべき？ Java String s = \"hoge\"; // s は明らかに null じゃないのでチェックしないで良さそう String ss = Fuga(); // 文字列か null を返す関数だとしたら // ss は要チェック チェックの要・不要を判断するのはプログラマ → 往々にして間違いが起こり得る アノテーションによる null 回避という案 Android Java では @NonNull のようなアノテーションをメソッドに付与できる @NonNull をつけておくと、コンパイル時にある程度 null にならないことをチェックできる しかし基本的に無力 表明するためのものでありドキュメンテーションの色合いが強い IDE は @NonNull なところに null になりうる変数を渡すと警告してくれる (こともある) 制約に違反するコードがあってもコンパイルエラーにはしてくれない Java // アノテーションによって本メソッドは null を返さないことを表明する @NonNull String Fuga() { // ... return null; // しかし null は返すことはできてしまう (コンパイルエラーではない) } // null になりうることも表明できる @Nullable String Piyo() { // ... } null 安全 そんなわけで null にはさんざん苦戦してきた Kotlin では、「null になりうるか」「null になりえないか」を「型」で区別している fun main(args: Array) { //sampleStart // たとえば、以下のコードはコンパイルに失敗する // String は「null になりえない」型であるから val s: String = null // error: null can not be a value of a non-null type String //sampleEnd } fun main(args: Array) { //sampleStart // 「null になりえる」型を宣言するためには、? を補う // 以下はコンパイル OK val s: String? = null // ただし、「null になりえる」の状態のままではメソッド、プロパティの呼び出しができない // error: only safe (?.) or non-null asserted (!!.) calls are // allowed on a nullable receiver of type String? println(s.uppercase()) // たとえ値が入っていても同様 val ss: String? = \"hoge\" // error: only safe (?.) or non-null asserted (!!.) calls are // allowed on a nullable receiver of type String? println(ss.uppercase()) //sampleEnd } スマートキャスト 「null になりえる」の状態では、メソッドやプロパティが呼び出せない メソッドやプロパティを呼び出すためには、「null になりえる」の状態から「null になりえない」に変換が必要 たとえば if 文による null チェックで対象が「null になりえない」ことが分かれば良い fun main(args: Array) { //sampleStart // スマートキャストを使った「null になりえる」から「null になりえない」への変換 val s: String? = \"hoge\" // 「null になりえる」状態 if (s != null) { // null チェックすることで s は「null になりえない」になる println(s.uppercase()) // メソッドが呼び出せる } //sampleEnd } 安全呼び出し 対象が「null だったら null、null じゃなかったら中身」を使うやり方 fun main(args: Array) { //sampleStart // ? をつけると「null になりえる」型 val s: String? = \"hoge\" // 通常、このままでは s のメソッドを呼べないが、 // ? を補うことで呼び出せる val u = s?.uppercase() println(u) // 上記は以下と同じ処理 val up = if (s != null) { s.uppercase() } else { null } println(up) //sampleEnd } メソッドの引数に「null になりうる」を渡す場合 fun main(args: Array) { //sampleStart // 以下の関数の引数の型は「null になりえない」という記述 fun greet(name: String) { println(\"hello, $name!\") } val s: String? = \"hoge\" greet(s) // コンパイルエラー if (s != null) { greet(s) // これなら OK } //sampleEnd } 上記のような例の場合に、let を用いることができる let は任意の型とラムダ式を引数にとり、ラムダ式を呼び出す fun greet(name: String) { println(\"hello, $name!\") } fun main(args: Array) { //sampleStart val s: String? = \"hoge\" // コンパイル OK // s が null ならラムダ式は呼び出されない s?.let { greet(it) } //sampleEnd } 強制呼び出し !! を使うと「null になりうる」を「null になりえない」に強制的に変換する 中身が本当に null だったら NullPointerException になっちゃうので、基本的に使わないで済ませたい 対象の変数が 100%ヌルでない ということが分かっているなら使っていいかもしれない が、そういうときにもあえて強制呼び出しオペレータを用いる必要はなく、もっと良い書き方ができるはず fun main(args: Array) { //sampleStart val s: String? = \"hoge\" println(s!!.uppercase()) // コンパイルOK、実行も可能 //sampleEnd } fun main(args: Array) { //sampleStart val s: String? = null println(s!!.uppercase()) // コンパイルOK、だが実行時に例外 (NullPointerException) を吐く //sampleEnd } エルビス演算子 null のときに返す値を指定できる ちなみに三項演算子（a > 0 ? \"1以上\" : \"0以下\"）とは別物 三項の方はKotlinでは使えない fun main(args: Array) { //sampleStart val s: String? = null println(s ?: \"null です！\") // null だったら「null です！」を出力 // 以下と同義 if (s != null) { println(s) } else { println(\"null です！\") } //sampleEnd } 安全キャスト 型をキャストする際にも ? が使える キャストに失敗したときに例外ではなくて null が返る fun main(args: Array) { //sampleStart val a: Any = \"string\" // String を Any に入れる println(a as String) // String へのキャストは OK (\"string\" が表示される) println(a as Int) // java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer //sampleEnd } fun main(args: Array) { //sampleStart val a: Any = \"string\" // String を Any に入れる println(a as? String) // String へのキャストは OK (\"string\" が表示される) println(a as? Int) // null が表示される //sampleEnd } "},"tips.html":{"url":"tips.html","title":"その他豆知識","keywords":"","body":"その他豆知識 その他、豆知識を記載します。 ゴール 以下について理解していること ObjectとCompanion Object 演算子オーバーロード 等価、同値 (=== と ==) 分解宣言 列挙型 例外 再起呼び出しと末尾再起呼び出し最適化 ローカル関数 coroutine apply also by lazy ※一部は時間の都合上、記載省略 ObjectとCompanion Object Object Objectは一言で言えば「シングルトン（Singleton）なクラス」だが、ここでは使用例を見せながら説明する。 どこからでも呼び出せるログ出力関数が欲しいとしよう。 今まで習った内容を使って書くとこうなる。 class Logger { val TAG = \"MyApp\" fun debug(text: String) { println(\"$TAG: $text\") } } fun main(args: Array) { println(\"Logging to ${Logger().TAG}.\") Logger().debug(\"print\") } 出力結果 Logging to MyApp. MyApp: print ただし、このコードには問題があって、Logger().で毎回異なるインスタンス（オブジェクトの実体）が作られる。この例だとmainの中で2回作られている。 もし、debugがあちこちから大量に呼ばれたら…たちまちインスタンスが乱立して、メモリを圧迫し、アプリの動作が重くなるだろう。 それを避けるため、クラスをobjectキーワードで定義する。 object Logger { val TAG = \"MyApp\" fun debug(text: String) { println(\"$TAG: $text\") } } fun main(args: Array) { println(\"Logging to ${Logger.TAG}.\") Logger.debug(\"print\") } こうすると、クラスLoggerと変数TAGは何回呼ばれても常に同じインスタンスを返す。何度呼ばれても、メモリ圧迫量は変わらない。これがシングルトン。 呼び出し方はLogger.に変わる。 Companion Object さて、上記の例だと、TAGもdebugもシングルトンとして生成されるが、時にはTAGだけに適用したい場合もある。 その場合、companion objectキーワードを使うと、TAGをLoggerクラスに属するシングルトン変数、つまり「定数」にできる。 class Logger(outputFilePath: String) { companion object { val TAG = \"MyApp\" } fun debug(text: String) { // TODO 実際はoutputFilePathにファイル出力するよう作り替える println(\"$TAG: $text\") } } fun main(args: Array) { println(\"Logging to ${Logger.TAG}.\") Logger(\"/log.txt\").debug(\"print\") } mainを見ると、Loggerは普通のクラスだが、TAGはシングルトンであることがわかる。 実際、Key/Valueを扱い、Keyだけが定数、という実装がよくある。 また、Androidでは画面から他画面のデータ渡しでリクエストコードやKey/ValueペアのBundleを使うので、そういうときCompanion Objectはよく使われる。 余談 勘のいい人なら気づいたであろうが、この例の場合、実はクラスを使わずdebug()を実装する方法もある。 val TAG = \"MyApp\" fun debug(text: String) { println(\"$TAG: $text\") } fun main(args: Array) { debug(\"print\") } このようにトップレベル関数を使うのが一番シンプルである。 今までの例は、シングルトンをわかりやすく説明するためである。 また、Javaを知ってる人ならstaticがあるじゃないかと思うかもしれないが、staticはKotlinでは使えない。 静的なものは非オブジェクトだから、オブジェクト指向の言語において不要だろうという言語設計思想のため。 まとめ Objectは、「クラス/変数として毎回同じインスタンスを返したい場合」に使う Companion Objectは、「毎回同じインスタンスを返す変数（定数）をクラスに持たせたい場合」に使う と覚えておこう。 列挙型 定数を列挙する場合に便利な書き方。 enum class Kanto { IBARAKI, TOCHIGI, GUNMA, SAITAMA, CHIBA, TOKYO, KANAGAWA } fun main(args: Array) { println(\"Kanto Prefecture List: \") for (prefecture in Kanto.values()) { println(prefecture) } println(\"I'm living in ${Kanto.TOKYO}.\") } 例外 異常が起こった場合、関数は例外をスローできる。関数の呼び出し元では、その例外をキャッチして処理できる。 fun validation(percentage: Int) { if (percentage !in 0..100) { throw IllegalArgumentException(\"A percentage must be between 0 and 100 [parameter: $percentage]\") } } fun main(args: Array) { validation(101) } 値が0〜100の範囲に収まっていない場合は、IllegalArgumentExceptionをスローする。 Exception in thread \"main\" java.lang.IllegalArgumentException: A percentage must be between 0 and 100 [parameter: 101] at FileKt.validation (File.kt:3) at FileKt.main (File.kt:8) at FileKt.main (File.kt:-1) 再帰呼び出し 普通の再帰呼び出し fun main(args: Array) { //sampleStart // Long のリストを引数にとって合計を返す関数 // sum 関数内で sum 自身を呼び出している fun sum(numbers: List): Long = if (numbers.isEmpty()) 0 else numbers.first() + sum(numbers.drop(1)) // 上記のコードは引数に渡した配列が超長い場合などにちゃんと動かなくなる // (stack overflow してしまう) sum((1L..123456).toList()) // stack overflow しちゃう！ //sampleEnd } 末尾呼び出し最適化 fun main(args: Array) { //sampleStart // 再帰的に関数を呼び出す場合において、その関数呼び出しが関数の一番最後にくる場合、 // 「末尾呼び出し最適化 (Tail Call Optimization)」と呼ばれる最適化を行うことができる // * 関数定義の頭に tailrec をつける // * 再帰呼び出しを関数の最後にもっていく tailrec fun sum(numbers: List, acc: Long = 0): Long = // ← tailrec というのをつけた if (numbers.isEmpty()) acc else sum(numbers.drop(1), acc + numbers.first()) // sum の再帰呼び出しが関数の最後にきている // 動く！ただしタイムアウトするかも sum((1L..123456).toList()) //sampleEnd } ローカル関数 ローカル関数は関数の中に関数を定義できる仕組み 他の関数からは呼び出すことができない (関数内にスコープを限定) 以下はローカル関数と再帰呼出しの組み合わせ fun main(args: Array) { //sampleStart fun sum(numbers: List): Long { // 引数を 2 つとる関数をローカル関数化し、 // 外面を良く (引数 1 個で済むように) した tailrec fun go(numbers: List, acc: Long): Long = if (numbers.isEmpty()) acc else go(numbers.drop(1), acc + numbers.first()) return go(numbers, 0) } sum((1L..10).toList()) //sampleEnd } apply オブジェクトに対し、プロパティの変更を一括適用する class Company ( var name: String, var numberOfEmployees: Int = 0 ) fun main(args: Array) { val c = Company(\"ACCESS\", 310).apply { // 今年の新卒社員数を加算 numberOfEmployees += 15 } val s = \"${c.name} has ${c.numberOfEmployees} employees.\" println(s) // ACCESS has 325 employees. } プロパティの数が多い場合、c.xxx = yyyみたいな記述を繰り返す手間が省ける also, let alsoはapplyと似ており、applyがラムダ式の中でthis（あるいはアクセッサーを省略）を使うのに対し、alsoはラムダ式の中で別の名前を付けられる デフォルトはit つまり、applyの場合はラムダ式の内外でthisの指す先が異なるが、alsoを使うと同じになる fun main(args: Array) { //sampleStart val s = \"access\".also { it.uppercase() } println(s) //=> access //sampleEnd } letはalsoと似ており、letが最後の行を返すのに対し、alsoは元のオブジェクトを返す fun main(args: Array) { //sampleStart val s = \"access\".let { it.uppercase() } println(s) //=> ACCESS //sampleEnd } by lazy 遅延プロパティと呼ばれる 最初にアクセスがあった時に、ラムダの中身を計算し、最終行の値をvalに保持する それ以降は、単に保持された結果を返す val greetMessage: String by lazy { println(\"First time!\") \"Hello!\" } fun main(args: Array) { println(greetMessage) // \"First time!\\nHello!\" println(greetMessage) // \"Hello!\" } 実際は、画面の起動時には設定できないけど、更新時にはじめて設定できるものとかに使う それはvarでも実装できるが、by lazyの場合valにできるのが利点 "},"exercise1.html":{"url":"exercise1.html","title":"Exercise (1)","keywords":"","body":"Exercise (1) Hello World! まずはこれ！ソースをコンパイルしてとりあえず動かすところまでやってみよう！ 動作確認の方法については、基本的な文法 - Kotlin Playground を参照のこと。 つまり、以下を Run してみよう！ fun main(args: Array) { println(\"Hello world!\") } Fizz Buzz 基本的な文法、関数の使い方を抑えたところで、以下の練習をやってみよう！ 入力は 1〜100 3の倍数の時は「Fizz」を出力 5の倍数の時は「Buzz」を出力 3の倍数かつ5の倍数の時は「FizzBuzz」を出力 それ以外のときはそのまま数字を出力 出力例 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz ... FizzBuzz 91 92 Fizz 94 Buzz Fizz 97 98 Fizz Buzz ポイント if 文、for ループが使えれば解けるはず when を使って短く書いたりもできる fun main(args: Array) { for (i in 1..100) { // 実装する } } 余裕があれば fizzBuzz 関数を書いて main を短くしよう！ うるう年 入力された数字を西暦としたときに、うるう年かどうか判定する関数を書いてみよう！ 入力は 0 以上の Int うるう年ならば true、そうでないならば false を返す ところでうるう年って？ 年が 4 で割り切れる場合、その年はうるう年として扱う。ただし、100 で割り切れてかつ 400 で割り切れない年は除く 1700、1800、1900、2100、2200、2300、2500、2600 はうるう年ではない 1600、2000、2400 はうるう年 // うるう年かどうかを判定する関数 fun isLeapYear(y: Int): Boolean { // TODO: 実装する } fun main(args: Array) { for (i in 2000..2100) { if (isLeapYear(i)) { println(\"$i 年はうるう年です！\") } } } 結果を検証しよう！ https://citizen.jp/support-jp/manual/terms/deeper_01.html 累乗 数字をふたつ引数にとって (a、n とする)、a の n 乗を返す関数を書いてみよう！ 入力は a、n 共に任意の数 (正の数でも負の数でも浮動小数点でも OK) とする …とすると考慮することが非常に増えるので、ここではひとまず、いずれも正の整数とする 余裕があったら浮動小数点も取れるようにしてみよう！ fun power(a: Int, n: Int): Long { if (a ) { println(power(2, 3)) // 8 println(power(4, 6)) // 4096 println(power(-1, 2)) // inputs must be positive. return 0 -> 0 // println(power(2.0, 3.0)) // 8.0 // println(power(4.5, 6.7)) // 23797 // println(power(-1.0, 2.0)) // inputs must be positive. return 0 -> 0.0 } "},"exercise2.html":{"url":"exercise2.html","title":"Exercise (2)","keywords":"","body":"Exercise (2) クラスの使い方を抑えたところで、以下の練習をやってみよう！ 奇数か偶数か Int を拡張して、isOdd、isEven メソッドを追加してみよう！ isOdd ... 数が奇数であるときに true を返し、偶数のときに false を返すメソッド isEven ... 数が偶数であるときに true を返し、奇数のときに false を返すメソッド // TODO: isOdd と isEven を拡張メソッドで実装する fun main(args: Array) { val a = 5 println(a.isOdd()) // true println(a.isEven()) // false } n 面のサイコロ サイコロクラス (Dice クラス) にプロパティ、メソッドを使って以下の機能を実装してください 「サイコロを振る」メソッド roll を備える roll は Int をひとつ返すメソッド。返る値は 1 以上 diceFace 以下。ただし diceFace はコンストラクタの引数で与えられた値。 100 回振ると壊れて、101回目以降は例外 Exception(\"I was broken\") を投げる 別の Dice インスタンスを作ればまた roll できる import kotlin.random.Random class Dice(private val diceFace: Int) { // TODO: class Dice を完成させる fun roll(): Int { // ヒント：以下は、0〜5 までの値がランダムで返る val n = Random.nextInt(6) return n } } fun main(args: Array) { val d = Dice(16) for (i in 1..100) { println(d.roll()) // 1〜16 までの数字 } println(d.roll()) // Exception } 呼び出した回数をカウントする カスタムセッターを使って、何度呼び出されたかをカウントしてみよう！ class MyCustomClass { var counter: Int = 0 var propertyWithCounter: Int = 0 /* TODO: ここにカスタムセッターを書く */ } fun main(args: Array) { val p = MyCustomClass() p.propertyWithCounter = 123 p.propertyWithCounter = 456 p.propertyWithCounter = 789 println(p.counter) // 3 } 世界のナベアツ ところで、世界のナベアツはご存知でしょうか。 現在は落語家になっていらっしゃる。高座名は「桂三度」 彼の持ちネタ「3の倍数と3が付く数字のときだけアホになります」というのがいっとき (2008年前後と思われる) 流行った 詳細は wikipedia 等を参照されたし ということで、ナベアツクラスを作ってみよう！ next というメソッドを持つ。戻り値は String ナベアツは内部的にカウンターを持っており、next が呼び出されるたびにカウンターを 1 つずつ増やしていく 内部カウンターが「3の倍数と3が付く数字のとき」、next は Aho を返す それ以外のときは、カウンターの値を文字列にしたものをそのまま返す class NabeAtsu { // TODO: 実装する fun next(): String { // TODO: 実装する } } fun main(args: Array) { val n = NabeAtsu() for (i in 1..100) { println(n.next()) } } # 実行例 (実際は改行されますがスペースの関係で横に書きます) 1 2 Aho 4 5 Aho 7 8 Aho 10 11 Aho Aho 14 Aho 16 17 Aho 19 20 Aho 22 Aho Aho 25 26 Aho 28 29 Aho Aho Aho Aho Aho Aho Aho Aho Aho Aho 40 41 Aho Aho ... "},"exercise3.html":{"url":"exercise3.html","title":"Exercise (3)","keywords":"","body":"Exercise (3) ヌルと戦うJavaプログラマーにKotlinを教えよう！ あなたの部署には、Kotlinをまったく知らないJava開発者のN内さんがいます。 N内さんは、上司の指示でJavaのコードをKotlinに書き直して、あなたにレビューをお願いして来ました。 N内さんは「漏れなくnullチェックできてるし！！」と自信満々だが、そのコードにはたくさんのビルドエラーがあります。 あなたは呆れ顔で、このコードの問題を指摘します。 問題 正しい出力結果 To: antonio@example.com message: Hello, Antonio! が出るよう、以下の条件を守り、コードをできる限り短く読みやすく修正してください。 /* ここからは変えない */〜/* ここまでは変えない */の間は変えないこと 予め定義されているクラスをすべて使うこと つまりmainにprintlnで直接出力結果を書くことは許されない ifを使うのは1回まで /* ここからは変えない */ class Client (val personalInfo: PersonalInfo?) class PersonalInfo (val email: String?) interface Mailer { fun sendMessage(email: String, message: String) } class CosmosMailer: Mailer { override fun sendMessage(email: String, message: String){ println(\"To: $email\\nmessage: $message\") } } /* ここまでは変えない */ fun sendMessageToClient(client: Client?, message: String?, mailer: Mailer) { if (client == null || message == null) { return } val personalInfo: PersonalInfo = client.personalInfo if (personalInfo == null) { return } val email: String = personalInfo.email if (email == null) { return } mailer.sendMessage(email, message) } fun main(args: Array) { val personalInfo: PersonalInfo = PersonalInfo(email: \"antonio@example.com\") val client: Client = Client(personalInfo: personalInfo) val mailer: Mailer = CosmosMailer() sendMessageToClient( client: client, message: \"Hello, Antonio!\", mailer: mailer ) } 参考までに、下記が移植前の Java コードの一部 引数のアノテーションによると、client、message は null の可能性がある 引数のアノテーションによると、mailer は null の可能性がない 途中で null に出くわしたらに何もせず return している Java public void sendMessageToClient( @Nullable Client client, @Nullable String message, @NonNull Mailer mailer) { if (client == null || message == null) return; PersonalInfo personalInfo = client.getPersonalInfo(); if (personalInfo == null) return; String email = personalInfo.getEmail(); if (email == null) return; mailer.sendMessage(email, message); } "},"android_dev_environment.html":{"url":"android_dev_environment.html","title":"Android開発環境の構築","keywords":"","body":"開発環境の構築 Kotlin 研修おつかれさまでした！ これから待ち受ける実習課題にそなえ、 Kotlin で Android 開発を行うための環境構築について記載します。 ゴール サンプルプロジェクトをclone する clone したサンプルプロジェクトを Android Studio で読み込む サンプルアプリを実行する 想定する事前準備 以下はあらかじめ用意されていることを想定 ターミナルで git コマンドが実行できるようになっていること Android Studio (バージョン Bumblebee 2021.1.1 以降) がインストールされていること サンプルプロジェクトを clone する サンプルプロジェクトは以下 https://github.com/access-company/TrainingProject_Nekonosuzu ターミナルを開き、任意の位置に clone する 以下のようなコマンドを打つ$ git clone https://github.com/access-company/TrainingProject_Nekonosuzu.git 正常に完了すると、リポジトリのソースコード一式がダウンロードされる clone したサンプルプロジェクトを Android Studio で読み込む Android Studio を起動し、Open を選ぶ ファイルエクスプローラが起動するので、先程 clone した TrainingProject_Nekonosuzu のフォルダを選び Open する ファイルではなくフォルダを選ぶ 自動的にビルドが始まり、必要なもののダウンロード等が始まる サンプルを実行しよう Android 端末を PC に USB で接続しよう 事前に Android 側で開発者向けオプションと USB デバッグを有効にすること(参考） Android Studio の Run メニューからサンプルアプリを実行しよう うまく動いただろうか 実機がなくても、エミュレーターを作成して実行することができる 余裕があれば調べてやってみよう それでは、実習にのぞんでください！ "},"design_pattern.html":{"url":"design_pattern.html","title":"デザインパターン","keywords":"","body":"デザインパターン ゴール デザインパターンについて浅く知る ここでは、メジャーなパターンやキーワードをいくつか知っておくとよい 聞いて習得できる知識ではない。実践が大事！ オブジェクト指向におけるデザインパターンとは ソフトウェアの設計に、建築工学で使われるデザインパターンを取り入れたもの 一言で言えば、よくある課題を解決できる設計集 たとえば継承には Template Method パターン、委譲には Strategy パターンのように、設計の型がある モバイルアプリ開発では、委譲型の Delegation パターン、継承と委譲のどちらでもよい Adapter パターンとかが多用される GoF のデザインパターンと呼ばれる古典的デザインパターン以外に、言語やフレームワークによって新しいパターンが年々生まれ続けている 最近は言語やフレームワークの流儀に従っていれば自然と良いパターンに導かれることが多い 採用する利点 慣れてくると、他人のコードを「これは◯◯パターンだな」とか読める 技術者間の共通の用語としての価値 Builder, Iterator, Observer, Singleton と言ったときに意思疎通が図りやすい 良い設計をするための教材としての価値 メジャーなデザインパターン 検索すればたくさん出てくるので、個人的に知っておいてほしいものだけ紹介 インスタンスの生成に関するパターン Factory Method 実際に生成されるインスタンスに依存しない、インスタンスの生成方法を提供する Abstract Factory 関連する一連のインスタンスを状況に応じて、適切に生成する方法を提供する Singleton あるクラスについて、アプリケーション内でインスタンスが単一であることを保証する 構造に関するデザインパターン Bridge クラスなどの実装と、呼出し側の間の橋渡しをするクラスを用意し、実装を隠蔽する Repository ビジネスロジックとデータ操作との間に 1 枚リポジトリレイヤーを挟み、データがサーバーにあるのか DB にあるのかとかを、ビジネスロジックが意識しないようにする Composite 再帰的な構造を表現する。Tree と呼ばれる場合もある 振る舞いに関するデザインパターン State 状態 1 つ 1 つを異なるクラスとし、あるインスタンスのクラスを切り替えることで状態を変化させる Iterator 複数の要素を内包するオブジェクトのすべての要素に対して、順番にアクセスする方法を提供する。反復子 Observer インスタンスの変化を他のインスタンスから監視できるようにする。Listener とも呼ばれる Strategy データ構造に対して適用する一連のアルゴリズムをカプセル化し、アルゴリズムの切替えを容易にする アーキテクチャーとは デザインパターンより上位の基本構造や設計思想のこと 家やビルを建てるときに考える設計と似ている メソッド/クラス/モジュール を、どのように 分離/結合 するか ソフトウェア、特に Kotlin やモバイルアプリまわりでよく聞くのは、MVVM, MVC, MVP, MVI, Flux, クリーンアーキテクチャーなど 詳しくは ACCESS テックブック 第 1 章 クリーンアーキテクチャー p 9 〜 13（ 1.1 〜 1.4 節）を読んでください "},"communication_skill.html":{"url":"communication_skill.html","title":"コミュニケーション技法","keywords":"","body":"コミュニケーション技法 ゴール 各種コミュニケーションの技法・考え方の浅い紹介 現場では技術的な問題と同等（あるいはそれ以上）にコミュニケーションの問題が発生する よくある「顧客が本当に必要だったもの」などもコミュニケーション問題（それだけではない） 結論から伝える まず簡潔な結論から伝える 結論は文章であれば1-3行程度（できれば1行） 説明は後回し 結論から伝えるには結論を出してから再構成して伝える（話す/書く）必要がある 考えながらだと結論からにならない PREP法 PREP法とは、わかりやすい文章の構成例 Point (結論) Reason (理由) Example (実例) Point (結論) 結論タイプ 結論の種類は多くはない 例えば、はい/いいえ形式の質問であれば回答の本質は3種類に絞られる はい / YES できます/可能です/問題ありません、など いいえ / NO できません/無理です/問題があります、など 回答できません 質問の意味がよくわかりません/判断するための情報が不足しています/検討に時間がかかります、など こちらから何か伝える結論の本質は以下に絞られる 依頼 相手に明確なアクションを求める情報伝達 作業依頼、質問、確認依頼、承認依頼など 「～お願いします」というかたちになることが多い 条件付き依頼 特定条件でのみアクションを求める依頼 「もし知っていたら～教えてください」「手が空いていたら～してください」など 周知 相手に明確なアクションを求めない情報共有 ただし「知っていること」「覚えていること」は求められる 質問は何か？ 相手に反応して結論を答えるためには依頼内容（質問内容）を把握する 相手から来た文を読み直して依頼内容（質問内容）を明確にする 最初に書く結論は主題となる表面上の依頼内容（質問内容）に対する回答をする 本質的な問題を推測することも重要だが、まずは「聞かれていることの結論」を伝える ▼実例１（文章例） ユーザデータ移行プロジェクトでご協力をお願いしたい事項の一つとなります。 新アプリのリリース時に、ユーザに関するデータ移行を行う予定でおります。 キックオフ資料にございます通り、御社が管理されているデータベースのスナップショットをいただき、弊社AWSアカウント内に復元したデータベースから弊社管理のデータベースにデータを移行いたします。既に7月時点でのスナップショットはいただいておりますが、テーブル設計の変更やデータ量の変化を定期的に確認したいと考えております。キックオフにおいてはテーブル設計の変更の都度いただけないかご相談しておりましたが、定期的(1ヶ月ごと程度)にスナップショットをいただくことは可能でしょうか。難しい場合は時期や頻度等を含めましてご相談させていただきたいです。 依頼内容はなに？ 回答例を考えてみよう！ ▼実例２（文章例） 本件、影響範囲の確認方法につきまして、確認用アプリですと、 ・定期購読セクションの「定期購読キャンペーン」バナー表示 ・期間限定初月￥0キャンペーン実施中 ・「定期購読」ボタン 上記3点が確認可能かと認識しております。 「定期購読」ボタンを押した後のストア購入画面の定期購読購入価格も確認する必要がある場合は、バージョン3.0.58納品時にご対応いただいたような、キャンペーン確認版APKが必要かと思いますが、こちらにつきましては、ご対応いただくことは可能でしょうか。 依頼内容はなに？ 回答例を考えてみよう！ ロジカルに伝える 結論に至る理由をわかりやすく理論的に説明する 雲雨傘 何を提案するときは「事実」「推定」「提案」を明確化する 『雲がでてきたので』（事実） 『雨が降ってくるかもしれません』（推定） 『傘を持っていきましょう』（提案） 数字を使う 理由の説明として一番わかりやすい事実（根拠）は数字 大きな作業工数見積もりなどは細分化して数字で表す フェルミ推定を使う ▼実例３（見積報告） 依頼されていた見積ですが開発期間は以下の通り約2か月になります。 仕様（iOS/Android共通）: 5人日 Androidアプリ開発 : 16人日 iOSも同等程度と想定 : 16人日 試験工数は開発工数と同程度 : 16人日 合計工数は53人日 (5+16+16+16) iOSとAndroidは並行開発できるので開発期間は37営業日 (5+16+16) で約2か月 ＜見積詳細＞ 仕様調整（ iOS / Android アプリ共通）5 ディープリンクによる起動 0.5 サーバからの情報取得 1 各種表示 5 画面内アクション 0.5 ビューア起動時表示 1 完読時表示 1 既存ボーナスとの競合時処理 3 最終ページにスタンプカード画面への遷移ボタンを表示 1 開発者試験・コードレビュー・フィードバック 3 誰に説くのか？ 相手に応じて回答のレベルを調整する 技術職でない相手（顧客など）に専門用語を使って技術詳細を披歴しても煙たがられる 相手が理解できるレベルの説明に簡略化・抽象化して説明する アウトプット（成果物・回答）の粒度の認識を合わせておく 例えば「どのくらいでできますか？」という質問に対して 「人月レベルのだいたいの見積」が必要なのか「人日レベルの見積」が必要なのか 根拠となる見積詳細や正式な資料が必要か不要か 「パッと見の感覚での温度感」や「次回のミーティングまでに出来る範囲での見積」などの期限 リアクション ボールはどこにあるのか？ 依頼を受けて、すぐに回答できない場合は、まず依頼を受け取ったということを知らせる 短い返答やスタンプなど 回答時間の目安を知らせられるとなお良い 依頼を受けたり動きがあったら TODO (TBD, 残作業, アクション) をまとめる 「依頼」はボールがこちらにある 「条件付き依頼」は（基本的に）ボールは来ていない 「周知」はボールは来ていない 回答をしたときにボールが相手に行ったかどうか意識する 「一次回答」とか「継続して確認します」のような言い方だと相手は正式な報告を待っているかもしれない 複数対複数のやりとりではボールが行方不明になることは珍しくない 自分がボールを持っているか分からないときは確認する ▼実例４（文章例） > 弊社からのアプリ提供について、現在バージョンごとに DeployGate にて 運用会社様に提供しております。 > 御社にも DeployGate にて提供するのが良いと思いますが、こちら最大で20人までで残り枠は３人までとなっております。 > 追加の際は 運用会社様への相談の上追加となります。 上記承知いたしました。 残り枠を踏まえて一度社内確認した上で、運用会社様にもご相談を行わせていただければと存じます。 ボールはどちら？ "},"./":{"url":"./","title":"Introduction","keywords":"","body":"Kotlin introduction 目次 はじめに Kotlin Kotlin について 基本的な文法 関数 ちょっと特殊な関数 クラス 継承・抽象クラス インターフェース ジェネリクス Null安全 その他豆知識 Exercise Exercise (1) Exercise (2) Exercise (3) Android開発環境の構築 閑話 デザインパターン コミュニケーション技法 "}}