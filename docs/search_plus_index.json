{"overview.html":{"url":"overview.html","title":"はじめに","keywords":"","body":"はじめに 本ドキュメントは、株式会社 ACCESS 新卒研修において、Kotlin のレクチャを行う目的で作成しています。 文書について 以下のリポジトリで公開しています。https://github.com/access-company/kotlin_intro/ 誤り、改善点などあれば、issue、Pull request でのご指摘にご協力をお願いいたします。 参考文献 以下を参考にして作成されています。 Kotlin スタートブック Reference - Kotlin Programming Language Kotlin koans たくさん課題があるので、一通りやってみるととても良い！ "},"about_kotlin.html":{"url":"about_kotlin.html","title":"Kotlin について","keywords":"","body":"Kotlin について 生い立ち JetBrains 社が中心となって開発を行っているプログラミング言語 2011年夏に発表。現在は OSS (github のリポジトリ) として開発されている ライセンスは Apache 2.0 2021年4月現在、Kotlin はバージョン 1.4 1.4.31 が最新 プレビュー版としては 1.5.0-M1 あたりが出ている どんな言語か JVM 言語 コンパイルすると Java バイトコードになる Scala、Groovy なんかも JVM 言語 Java 互換 100％ Java で作られたライブラリを呼び出すことができる 逆に、Kotlin で作られたライブラリを Java から呼び出すこともできる なので、「Java か Kotlin か」ではなく、共存が可能 静的型付け (コンパイルしない系の言語に比べて) コンパイル時に誤りが発見されるという利点 オブジェクト指向 いわゆる C++、Java 等と同様で、クラスベースのオブジェクト指向言語 Android Studio 3.0 で標準サポート 初期 (2016〜2018年頃) はもっぱら Android のアプリ作成に用いられていた 徐々に他のプラットフォーム、サーバーサイド、Web、システムプログラミングでも使われ始めた モダンな言語仕様 型推論、ラムダ式、トレイトなど (Kotlin 1.2 から) JavaScript へのトランスパイルもサポート Java ではなくて Kotlin を使う理由 Java より記述が簡潔 型推論、ラムダ式、スマートキャスト、等の言語仕様 Java より安全 Null安全、キャスト周りの安全性 Kotlin は新しい Java にはモダンな言語仕様を入れにくい。下位互換をサポートしなければならないという事情 Kotlin は比較的新しいので、いわゆるしがらみが少なく、モダンな言語仕様をサポートしやすい "},"development_environment.html":{"url":"development_environment.html","title":"開発環境の構築","keywords":"","body":"開発環境の構築 Kotlin を用いた開発を行うための環境構築について記載します。 ゴール サンプルプロジェクトをclone する clone したサンプルプロジェクトを Android Studio で読み込む SampleTest を実行し、welcome メッセージを確認する Sample.kt を編集し、hello world を出す関数を定義する hello world を出す関数を SampleTest クラスから呼び出す 想定する事前準備 以下はあらかじめ用意されていることを想定 ターミナルで git コマンドが実行できるようになっていること Android Studio (バージョン 4 以降) がインストールされていること サンプルプロジェクトを clone する 本研修で使用するサンプルプロジェクトを用意しておいた サンプルプロジェクトはココ ターミナルを開き、任意の位置に clone する 以下のようなコマンドを打つ$ git clone https://github.com/access-company/KotlinTraining.git 正常に完了すると、リポジトリのソースコード一式がダウンロードされる clone したサンプルプロジェクトを Android Studio で読み込む 無事に clone は済んだだろうか 次に clone したソースコードを Android Studio で読み込む Android Studio を起動し、「Open an exisiting Android Studio project」を選ぶ ↑ Android Studio を開いたところ ファイルエクスプローラが起動するので、先程 clone したところを選ぶ ↑ clone したサンプルプロジェクトを選ぶ (アイコンが緑の丸っぽいのを選ぶ) 選ぶと自動的にビルドが始まり、必要なもののダウンロード等が始まったりする SampleTest を実行し、welcome メッセージを確認する SampleTest クラスを見つけてみよう 見つけたら、右クリックで選択し、Run 'SampleTest' を選択 welcome メッセージが出るかな Sample.kt を編集し、hello world を出す関数を定義する Sample.kt を探し、以下のようなコードを書いてみましょう。 fun hello() { println(\"Hello World!\") } hello を SampleTest クラスから呼び出す SampleTest を編集し、先ほど Sample.kt に定義した hello を呼び出してみよう うまく呼び出せただろうか "},"basic_syntax.html":{"url":"basic_syntax.html","title":"基本的な文法","keywords":"","body":"基本的な文法 Kotlin の基本的な文法について記載します。 ゴール 以下について、使い方を理解すること。 変数宣言 (var、val) 基本的なデータ型 基本的なデータ構造 (文字列、配列、リスト、セット、マップ、レンジ) 条件分岐 (if、when) ループ (while、for) Kotlin Playground ブラウザ上でサンプルを見ながら、その場でコードを書いて動作確認ができます。参考まで。 https://play.kotlinlang.org いろんな型 主に使われる型と、値の例を以下に記載 数値型 型名 ビット幅 用途 例 備考 Byte 8 bit 整数 0x0f, 0b0101, 123 -128 ~ 127 Short 16 bit 整数 0x0f, 0b0101, 1234 -32,768 ~ 32767 Int 32 bit 整数 0x0f, 0b0101, 1234 -2,147,483,648 ~ 2,147,483,647 Long 64 bit 整数 123456789L -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 Float 32 bit 浮動小数点 123.456F 単精度浮動小数点 Double 64 bit 浮動小数点 123.456 倍精度不動小数点 ちなみに、数値は読みやすさ向上のために任意の位置に _ を補った書き方ができる Int の最大値 → 2_147_483_674 クレジットカード番号 → 1234_5678_9012 マイナンバー → 987_65_4321 16進数を 1 byte ずつ区切る → 0xFF_EE_DD_CC 2進数を 1 byte ずつ区切る → 0b11010101_01011111_01010101 その他の基本型 型名 用途 例 Char 文字 'a', 'b', '0', '\\u8d64' String 文字列 \"hello\", \"How are you!\" Boolean 真偽値 true, false Unit \"ない\"ことを表す (Java の void にあたる) fun hoge(): Unit(戻り値がない関数の定義) 変数 val val で宣言した変数は、あとから値の変更 (再代入) ができない。 変数を扱う際には、可能な限りは val を用いたほうが良い。 var はコードの読みにくさやバグを招きやすい。 // val 変数名: 型 = 式 val foo: Int = 123 val bar: String = \"Hello\" var var で宣言した変数は再代入が可能。 // var 変数名: 型 = 式 var foo: Int = 123 var bar: String = \"Hello\" // あとから値が変えられる foo = 100 bar = \"World!\" 型推論 Kotlin コンパイラに、右辺から変数の型を推論してもらうことができる。 型推論を行う場合は、型名を省略して代入を行う。 val age = 35 // age の型は Int になる var name = \"access\" // name の型は String になる name = 12 // name の型は String なのでコンパイルエラーになる オブジェクト オブジェクトとは？→クラスのページで詳しく触れる。 文字列 (String) 文字列を表すオブジェクト。 色々なメソッド、プロパティが取り揃えられている。 String - Kotlin Programming Language (公式 API Reference) val str = \"access\" str.length // 6 str.capitalize() // \"Access\" str.isEmpty() // false // 文字列の連結 val str2 = \"Hello \" + str + \" !\" // + を使った連結 str2 // \"Hello access !\" val str3 = \"Good evening ${str}!\" // String テンプレートを使った連結 str3 // \"Good evening access! val str4 = \"Good night $str!\" // String テンプレートを使った連結 str4 // \"Good night access! 配列 // 配列を作るには arrayOfNulls を使う // Int の配列の場合は以下のような書き方 val ints = arrayOfNulls(10) // 各要素への値の代入 // (再代入も可能) ints[0] = 10 ints[1] = 20 // 中身はこうなる ints[0] // 10 ints[1] // 20 ints[2] // null // 要素数の取得には size プロパティを使う ints.size // 10 // arrayOf で書くと型推論される // 以下は String の配列ということにされる val array = arrayOf(\"access\", \"company\", \"com\") array[0] // \"access\" array[1] // \"company\" array[2] // \"com\" リスト // listOf でリストを作る。 val list = listOf(1, 2, 3) // 配列と同じように要素アクセスできる list[0] // 1 // 単なるリストは要素の値を変更できない // 要素の値を変更可能なリストが欲しい場合は MutableList を使う list[0] = 100 // コンパイルエラー セット // セットは「重複のない」集合を扱う場合に用いる val intSet = setOf(1, 2, 3, 4, 1, 3, 2) intSet // [1, 2, 3, 4] // 単なるセットは要素の値を変更できない // 要素を追加したり削除したりする場合は MutableSet を用いる intSet += 5 // コンパイルエラー // セットは要素の順番を保証しないので、配列みたいな添字での要素アクセスはできない intSet[2] // コンパイルエラー マップ // マップはキーと値のペアを保持するコレクション // 以下は という形のペアを保持できるマップ val map = mapOf(1 to \"access\", 2 to \"company\", 3 to \"com\") map[1] // \"access\" map[2] // \"company\" map[3] // \"com\" map[4] // null // ご多分に漏れず、単なるマップは値の変更ができない // 要素の値を変更可能なマップが欲しい場合は MutableMap を使う map[1] = \"fuga\" // コンパイルエラー レンジ .. を使って範囲を表すことができる 1..10 // 1〜10 の範囲を示す // in を使って、指定した値が範囲内にあるかチェックする 5 in 1..10 // true 100 in 1..10 // false // range もオブジェクトなので変数に入れたりできる val r = 1..10 5 in r // true // レンジからリストを得ることができる val list = r.toList() list // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 条件分岐 if 条件分岐に用いる else を伴うことで「式」として用いることが可能 (変数に代入したりできる) val r = 1..10 if (5 in r) { println(\"5 is in range\") } // 式として用いて変数に代入することも可能 val n = 5 val result = if (n in r) { \"$n is in range\" } else { // 式として用いるときには else 必須 \"$n is not in range\" } result // 5 is in range // else if で次々つなげることも可能 val age = 7 val fee = if (age > 12) { \"大人料金\" } else if (age >= 6) { \"小人料金\" } else { \"無料\" } when switch 文のようなもの (なお Kotlin に switch はない) if と同じく、else を伴うことで「式」として用いることが可能 // オーソドックスな when の使い方 val n = 5 when (n) { 1 -> \"access\" 2, 3 -> \"company\" else -> \"com\" } // is を用いた型チェック // 値の代入もできる val n = 5 val type = when (n) { is Int -> \"$n is Int\" else -> \"$n is not Int\" } type // 5 is Int // when のあとに値を伴わない書き方もできる val n = 5 when { // 以下、条件に一致したものがどれかひとつ実行される // 評価は上から順番に行われる n % 15 == 0 -> println(\"fizzbuzz\") n % 5 == 0 -> println(\"buzz\") n % 3 == 0 -> println(\"fizz\") else -> println(\"$n\") } // 定数以外も用いることができる val n = 5 when { n in 1..5 -> \"access\" n > 5 -> \"company\" else -> \"com\" } ループ while // while による繰り返し var count1 = 0 while (count1 // do-while も使えます // 単なる while は繰り返し 0 回 (＝何もしない) もできるが、 // do-while の場合はまず do の中身を一度実行してから繰り返す var count2 = 0 do { // 繰り返したい処理 count2++ } while(count2 // 無限ループ while (true) { // 繰り返したい処理 } for // for 文で繰り返し実行が可能なのは、 // イテレータを提供するオブジェクト (配列、リスト、レンジ、等) for (要素名 in イテレータオブジェクト) { // 繰り返したい処理 } // Int の配列の場合 val ints = arrayOf(1, 2, 3) for (n in ints) { println(n) // 1, 2, 3 が順番に出力される } // レンジを使う場合 var sum = 0 for (n in 1..10) { sum += n } sum // 55 // リストを使う場合 var sum = 0 val list = (1..10).toList() for (n in list) { sum += n } sum // 55 // 途中でループを抜けたり (break) // 次のループまでスキップしたり (continue) var count = 0 while (true) { count++ if (count == 10) { break // while ループを抜ける } if (count % 3 == 0) { println(\"3の倍数です！\") continue // 後ろの処理を行わずに次のループを開始する } println(count) } // ループが多重の場合は、 // どのループを抜けるかラベルで指定する outer@ for (i in 1..10) { // ← outer というラベルをつけたところ for (j in 1..10) { if ((i+j) % 3 == 0) { break@outer // 外側のループを抜ける // break のように何も指定しない場合、内側のループを抜ける } } } "},"function.html":{"url":"function.html","title":"関数","keywords":"","body":"関数 Kotlin の関数について記載します。 ゴール 以下について理解すること。 関数の定義の仕方、使い方 単一の式からなる関数 名前付き引き数、デフォルト引数 可変長引数 再帰呼び出し (末尾呼び出し最適化) ローカル関数 関数とは？ 何か（引数）を入れると、何らかの計算や処理を行って、入れた人に結果（戻り値）を返すもの。それ以上は省略。 色々な関数定義の仕方 基本形 // fun で始まる以下の形が基本の関数定義の仕方 fun 関数名(引数リスト): 戻り値の型 単一の式からなる関数の場合 // Int を 2 つとって足した数を返す関数 // 処理が一個しかない (式が一個) の場合はこんな風に書ける fun add(a: Int, b: Int): Int = a + b // Int を 2 つとって大きい方を返す関数 // if 文 1 個ということも可能 fun max(a: Int, b: Int): Int = if (a > b) a else b // Int を 2 つとって小さい方を返す関数 // 戻り値の型に型推論が効く fun min(a: Int, b: Int) = if (a 文を持つ // 文を扱うときはこう // Int を 2 つ引数に取って足し合わせた結果を返しつつ、画面に結果を出す関数 fun addWithPrint(a: Int, b: Int): Int { val result = a + b println(result) return result } // Int の配列を引数にとって全部足し合わせたものを返す関数 fun sum(ints: Array): Int { var sum = 0 for (n in ints) { sum += n } return sum } 名前付き引数 // どの引数に値を渡すか、引数の名前を指定できる fun name(first: String, last:String) = println(\"$first $last\") // 名前を指定せずに呼び出すとき name(\"taro\", \"yamada\") // taro yamada // 名前を指定して呼び出すとき // 関数定義の順番に従う必要がなく、意味も分かりやすくなる場合もある name(last = \"yamada\", first = \"taro\") // taro yamada デフォルト引数 // デフォルトの値を指定してくことができる // 呼び出し時に値を指定しなかった場合はデフォルト値が使われる fun greet(name: String = \"anonymous\") { println(\"Hi, $name!\") } greet() // Hi, anonymous! greet(\"BOB\") // Hi, BOB! 可変長引数 // 引数に \"vararg\" をつけると可変長 (任意の個数、引数入力が可能) という意味になる fun sum(vararg ints: Int): Int { // 引数として任意の数の Int をとる var sum = 0 for (n in ints) { sum += n } return sum } // 呼び出し例 sum(1, 2, 3, 4) // 10 // 配列を可変長引数として扱ってもらうこともできる var array = intArrayOf(1, 2, 3, 4, 5) sum(*array) // * をつけると配列を可変長引数として扱ってもらえる "},"first_class_function.html":{"url":"first_class_function.html","title":"ちょっと特殊な関数","keywords":"","body":"ちょっと特殊な関数の使い方 第一級オブジェクトとしての関数について記載します。 ゴール 以下を理解すること。 関数もオブジェクトとして扱える 高階関数 ラムダ式、クロージャ インライン関数 オブジェクトとしての関数 関数もオブジェクトの一種 // 関数のオブジェクトを変数に代入する例 // 入力を二乗する関数 fun square(i: Int) = i * i // 関数のオブジェクトを取得するときは \"::\" をつける // 変数に代入できる val func = ::square square(5) // 25 func(5) // 25 (square を呼び出したのと同じ) 関数オブジェクトの型は？ 関数オブジェクトもオブジェクトの一種なので「型」がある // 入力を二乗する関数 fun square(i: Int) = i * i // 上の関数は「Int を引数にとって Int を返す関数」という型なので、 // 「Int を引数にとって Int を返す関数」型の変数に代入できる val func1: (Int) -> Int = ::square // 型があっていれば代入できる // 型があってないと代入できない // 以下の関数は (String) -> Unit という型 fun greet(name: String) = println(\"Hello $name!\") val func2: (Int) -> Int = ::greet // 型があっていないので代入できない (コンパイルエラー) 関数を引数として渡したり戻り値にしたり (高階関数) // 関数を引数にとる関数 // 第二引数には「Int を引数にとる関数」を指定する fun printWith(ints: List, printFunc: (Int) -> Unit) { for (i in ints) { printFunc(i) // 引数でもらった関数を呼び出す } } // 「Int を引数にとる関数」の例 fun myPrintFunc(i: Int) { if (i % 3 == 0) { println(\"3の倍数です!\") } else { println(i) } } // 関数オブジェクトを第二引数に指定して呼び出す printWith((1..10).toList(), ::myPrintFunc) // n 乗を返す関数を生成する関数 fun powerGen(n: Int): (Int) -> Long { fun power(num: Int): Long { var result: Long = 1 for (i in 1..n) { result *= num } return result } return ::power } // 入力を 5 乗する関数を生成 val fivePowerOf = powerGen(5) fivePowerOf(10) // 100000 // 入力を 10 乗する関数を生成 val tenPowerOf = powerGen(10) tenPowerOf(2) // 1024 色々な関数の作り方 ラムダ式 関数を定義せずに関数オブジェクトを生成するコードをラムダ式と呼ぶ。 // 通常の関数オブジェクトを得る方法 // 関数定義 fun square(n: Int): Int { return n * n } // 定義された関数の名前に :: をつけて関数オブジェクトを得る println(::square) // fun square(kotlin.Int): kotlin.Int // 一方、ラムダ式を使う場合 // 関数の型 = { 引数リスト -> 関数の実装 } という形 val square: (Int) -> Int = { i: Int -> i * i // 最後に評価された式が返される。return しなくてよい。 } println(square) // (kotlin.Int) -> kotlin.Int println(square(3)) // 9 型推論すると短く書ける // 「Int を引数にとって Int を返す」を型推論してもらい、 // 関数の型の記載を省略 val square = { i: Int -> i * i } // または「Int を引数にとる」を型推論してもらい、 // 関数の実装における引数の型を省略 val square: (Int) -> Int = { i -> i * i } // 両方省略するとiの型がわからないので、省略できない(コンパイルエラー) val square = { i -> i * i // コンパイルエラー } // 引数が一個の場合、「it」と書ける val square: (Int) -> Int = { it * it } クロージャ コードを記述したときのスコープで変数が扱える (環境の捕捉、キャプチャを行う) 関数オブジェクトのこと。 // 呼び出すたびに数字を1つ増やす関数を返す fun genCounterFunc(): () -> Int { var count = 0 // ラムダ式の形で関数オブジェクトを返す // 以下の関数オブジェクトは「count 変数をキャプチャ」している return { count++ } } fun main(args: Array) { val func1 = genCounterFunc() val func2 = genCounterFunc() // func1 を呼び出すたびに、「func1 内の」変数が変更される println(func1()) // 0 println(func1()) // 1 println(func1()) // 2 // func2 を呼び出すたびに、「func2 内の」変数が変更される println(func2()) // 0 println(func2()) // 1 println(func2()) // 2 } インライン関数 関数がインライン展開 (関数呼び出しの場所に関数定義が挿入されるイメージ) される仕組み。 高階関数の扱いは呼び出しのコストが高いが、インライン関数でより効率よくできる場合がある。 // インライン展開なし fun log(debug: Boolean, message: () -> String) { if (debug) { println(message()) } } fun main(args: Array) { log(true, { \"log message\" }) // 表示される log(false, { \"log message\" }) // 表示されない } // もしくはlogの{}をカッコの外に出して、こう書ける fun log(debug: Boolean, message: () -> String) { if (debug) { println(message()) } } fun main(args: Array) { log(true) { \"log message\" // 表示される } log(false) { \"log message\" // 表示されない } } // インライン展開する inline fun log(debug: Boolean, message: () -> String) { if (debug) { println(message()) } } fun main(args: Array) { log(true) { \"log message\" // 表示される } log(false) { \"log message\" // 表示されない }) } // 上述の main 関数は、以下と概ね同義になる // debug が true でないときは、関数呼び出しまで到達しないコードになる fun main(args: Array) { if (true) { println(\"log message\") // 表示される } if (false) { println(\"log message\") // 表示されない } } // 非ローカルリターン // inline 展開を利用して、外側の関数を抜けるテク // 入力した文字列 (str) の全要素に対して何か (f) する関数 inline fun forEach(str: String, f: (Char) -> Unit) { for (c in str) { f(c) } } // 入力した文字列 (str) に数字が含まれているかどうかを返す関数 fun containsDigit(str: String): Boolean { forEach(str) { if (it.isDigit()) { // forEach が inline 展開されるため、 // この return はラムダ式 (fun forEach の f(c) 部分) じゃなくて // fun containsDigit を抜ける。 return true } } return false } // inline だが非ローカルリターンしたくない場合は、 // ラベルへのリターンを利用する // 入力した文字列 (str) に数字が含まれているかどうかを返す関数 fun containsDigit(str: String): Boolean { var result = false forEach(str) loop@ { if (it.isDigit()) { result = true return@loop // forEach を抜ける // return@forEach という書き方も可能 } } return result } 無名関数 ラムダ式のように関数オブジェクトを得るもうひとつの方法 inline 展開はできない // ラムダ式 (再掲) val square: (Int) -> Int = { i: Int -> i * i } // 無名関数 // 上記のラムダ式にあたる部分に関数を書くイメージ val square: (Int) -> Int = fun(i: Int): Int { return i * i // ラムダ式と違って要 return 文 } // 無名関数 省略版 val square: (Int) -> Int = fun(i : Int) = i * i "},"class.html":{"url":"class.html","title":"クラス","keywords":"","body":"クラス クラスについて記載します。 ゴール 以下について理解すること。 オブジェクト指向 基本的なクラスの作り方、使い方 メソッド プロパティ コンストラクタとイニシャライザ エクステンション オブジェクト指向とクラス 突然出てきた用語…まず「オブジェクト」って？ 物や事柄すべてのこと。人間とか、木とかもオブジェクト プログラミング的には、データと関数の集合体 「クラス」って？ オブジェクトの設計図 なぜクラスが要るの？ 同じオブジェクトを毎回ゼロから組み立てるのは大変だから オブジェクト指向って？ オブジェクトをクラスやインスタンスで表現し、効率よくアプリ全体を組み立てようって考え方 インスタンスについては、すぐ後で説明する 継承、インタフェース、カプセル化の理解も大事だが、ここでは省略 以前の研修で使われてた資料（参考までに） …と、これだけでは伝わらないと思うので、具体例へ 家計簿アプリを作る場合、どうする？ 機能が多いので、収支履歴機能、残高機能、口座機能、と機能別に設計するのが望ましい 収支履歴クラス、残高クラス、口座クラス、さらにユーザー情報クラスと分割 それぞれに必要なデータ(変数)と処理(関数)を持たせる。データだけのクラス、処理だけのクラスもあり得る クラスは、1つの機能を持ったプチOS、とイメージしてもよい クラスだけでは、データを保持できない。画面を表示してる間はデータを保持する必要がある そこでアプリは、クラスをコンピューターメモリ上に生産し、データ保持可能にする。その生産物がインスタンス オブジェクトと呼ぶこともある アプリは、必要なインスタンスを参照しながら、家計簿として振る舞う 例えば、残高と収支履歴のインスタンスを使って今月の家計簿を表示するなど クラスの作り方と使い方 クラスを定義する 以下、クラスにプロパティとメソッドを持たせる例。 // ヒトを表すクラス class Person { // プロパティ (名前) var name: String = \"\" // プロパティ (年齢、カスタムセッター付き) var age: Int = 0 set(i) = if (i = 20) { return true } return false } } クラスの使い方 (インスタンス化) クラスからオブジェクトを生成することをインスタンス化という fun main(args: Array) { // Person クラスのインスタンス化 val pankona = Person() // プロパティに値をセット pankona.name = \"yosuke akatsuka\" pankona.age = 37 // プロパティの値を参照する println(pankona.name) // yosuke akatsuka println(pankona.age) // 37 println(pankona.nameLength) // 15 // メソッドの呼び出し if (pankona.isAdult()) { println(\"pankona belongs to adult team\") } else { println(\"pankona belongs to young team\") } } バッキングフィールド 値を実際に置かれている領域のこと カスタムゲッターを置くとバッキングフィールドはなくなる プロパティと呼んでいるのは、バッキングフィールドにアクセスするための窓口 // ヒトを表すクラス (再掲) class Person { // これらのプロパティはバッキングフィールドを持つ var name: String = \"\" var age: Int = 0 // カスタムゲッターを設定 // 本プロパティにはバッキングフィールドがない val nameLength: Int get() = name.length } lateinit バッキングフィールドをもつプロパティは、宣言と同時に値を入れる (初期化) が必須 ただ、それだと困る場合があるので初期化を遅らせる lateinit という仕組みがある lateinit は var にのみつけられる lateinit をつけていて値の初期化を行う前にプロパティにアクセスすると kotlin.UninitializedPropertyAccessException という例外がスローされる Android アプリの開発においては割と多様される (諸説ある) // コンパイルが通らないヒトを表すクラス class Person { // これらのプロパティはバッキングフィールドを持つ // そのため、以下のように宣言時に初期化をしないとコンパイルエラーになる var name: String // コンパイルエラー！ var age: Int // コンパイルエラー！ } // lateinit を使ってコンパイルが通るヒトを表すクラス class Person { // lateinit を使うと、宣言時に初期化しなくて良い lateinit var name: String } fun main(args: Array) { val p = Person() // p.name は未初期化なので、このまま触ると // kotlin.UninitializedPropertyAccessException が発生 println(p.name) } this クラス内で別のプロパティ、メソッドにアクセスする際に使える 省略しても良い。 // ヒトを表すクラス (再掲) class Person { var name: String = \"\" var age: Int = 0 val nameLength: Int get() = this.name.length // ← this をつけて name を参照 } コンストラクタ インスタンスを生成する際に、各プロパティの初期化を補助する仕組み // ヒトを表すクラス // コンストラクタの書き方は従来はこう。 class Person constructor(n: String, a: Int) { var name: String = n var age: Int = a } fun main(args: Array) { // コンストラクタを用いたインスタンスの初期化 val p = Person(\"yosuke akatsuka\", 37) println(p.name) // yosuke akatsuka println(p.age) // 37 } // ヒトを表すクラス // コンストラクタに val、var を伴うことで、そのままプロパティとして扱うこともできる。 class Person constructor(val name: String, val age: Int) fun main(args: Array) { // 前の例と同じように使える val p = Person(\"yosuke akatsuka\", 37) println(p.name) // yosuke akatsuka println(p.age) // 37 } // ヒトを表すクラス // ちなみに、constructor の文字は省略が可能 (先述のものと意味は同じ) class Person (val name: String, val age: Int) コンストラクタの色々 クラス名の横にコンストラクタを書く場合、それを「primary constructor」と呼ぶ。 クラスの中にふたつめ以上のコンストラクタを書く場合、それ (ら) を「secondary constructor」と呼ぶ。 primary constructor がある場合、secondary constructor は primary constructor を呼び出す必要がある。 primary constructor に処理は書けないが、secondary constructor には処理が書ける。 primary constructor で処理が書きたい場合は、後述のイニシャライザを用いる。 // ヒトを表すクラス // 別引数を持つ2つ目のコンストラクタを定義することもできる class Person (val name: String, val age: Int) { // 引数なしのコンストラクタを定義 // this を使って ↑ のコンストラクタを呼び出す constructor() : this(\"anonymous\", 999) { println(\"this is secondary constructor!\") } } イニシャライザ primary constructor が解決された後に呼び出される部分 constructor では足りない初期化処理を行う場合はここでやる エラー処理 (例外を発生させる) のであればここで // ヒトを表すクラス class Person(val name: String, val age: Int) { init { // 条件を満たさない場合は例外をスロー // java.lang.IllegalArgumentException: Failed requirement. require(age >= 0) } } fun main(args: Array) { val p = Person(\"pankona\", -10) // 例外発生 } クラスの拡張 拡張関数 既存のクラスにメソッドを追加する仕組み // 文字列の長さを取得する関数を普通に作ると fun strlen(str: String) = str.length fun main(args: Array) { strlen(\"hogehoge\") // 8 } // 文字列の長さを返す関数 size を String クラスに生やす // オブジェクトへの参照を得るには this が使える (省略可) fun String.size() = this.length fun main(args: Array) { \"hogehoge\".size() // 8 } 拡張プロパティ 既存のクラスの拡張はメソッドのみならず、プロパティの追加もできる。 ただしバッキングフィールドは追加できない。 // 文字列の長さを返すプロパティを生やす val String.size: Int get() = this.length fun main(args: Array) { \"hogehoge\".size // 8 } データクラス data class の定義 クラスを単にデータの塊として表現したいときに用いる 通常のクラス定義の頭に data をつける // ヒトクラス (data が頭にくっついている) data class Person(val name: String, val age: Int) data class の特徴 // 同じ名前と年齢を与える val p1 = Person(\"access\", 37) val p2 = Person(\"access\", 37) // 以下は true になる p1 == p2 // true // println に渡すといい感じに表示される println(p1) // Person(name = access, age = 37) // copy 等の便利メソッドが生える val p3 = p1.copy() println(p3) // Person(name = access, age = 37) // copy は一部のプロパティだけついでに変更したりもできる val p4 = p1.copy(age = 17) println(p4) // Person(name = access, age = 17) data class を使うと嬉しい場面 通常のクラスを用いると、上記の比較は p1 と p2 はイコール判定されない copy 等の便利メソッドを自動的に生やしてくれる 以下は通常のクラスとの違い // ヒトクラス class Person(val name: String, val age: Int) // 同じ名前と年齢を与える val p1 = Person(\"access\", 37) val p2 = Person(\"access\", 37) // p1 と p2 は、「値は同じかもしれないが違うオブジェクト」なので // 下記の評価結果は false になる p1 == p2 // false // println に渡しても内容は表示されない println(p1) // Line_5$Person@3bd42f5b // copy メソッドがないのでコピーできない val p3 = p1.copy() // メソッドがないのでエラー // 以下をやると参照のコピーになる (p1 を変更すると p4 も変更される) val p4 = p1 "},"inherit_abstract.html":{"url":"inherit_abstract.html","title":"継承・抽象クラス","keywords":"","body":"継承・抽象クラス クラスの継承・抽象クラスについて記載します。 ゴール 以下を理解していること。 継承の振る舞い 抽象クラスの使い方、抽象クラスの存在意義 オーバーライドの仕方 (open) 可視性 (public、internal、private、protected) 継承 継承とは ざっくり言えば「あるクラスの性質を別のクラスに引き継ぐ」ための仕組み クラスを継承 // ヒトクラス class Person(val name: String) { // 名前の長さを返すプロパティ val nameLength: Int get() = name.length // どこで生まれたかを返すメソッド fun bornFrom() = \"unknown\" } ヒトクラスを継承してみる このままでは継承はできなくて、open をつける必要がある 継承すると、メソッド一式とプロパティ一式を継承先は引き継ぐ // open がついて継承可能になったヒトクラス open class Person(val name: String) { // 名前の長さを返すプロパティ val nameLength: Int get() = name.length // どこで生まれたかを返すメソッド fun bornFrom() = \"unknown\" } // ヒトクラスを継承して男クラスと女クラスを作る // (コンストラクタに val がついてない点に注意) class Man(name: String) : Person(name) class Woman(name: String) : Person(name) fun main(args: Array) { val p = Person(\"p\") p.nameLength // 1 p.bornFrom() // unknown // 各々、Person から引き継いだプロパティが利用できる val m = Man(\"bob\") println(m.name) // bob println(m.nameLength) // 3 println(m.bornFrom()) // unknown val w = Woman(\"alice\") println(w.name) // alice println(w.nameLength) // 5 println(w.bornFrom()) // unknown } メンバのオーバーライド プロパティ、メソッドを継承先で上書きする仕組み オーバーライドするためには、オーバーライドするプロパティ、メソッドに open をつける // open がついて継承可能になったヒトクラス open class Person(val name: String) { // open がついて継承が可能になった名前の長さを返すプロパティ open val nameLength: Int get() = name.length // open がついて継承が可能になったどこで生まれたかを返すメソッド open fun bornFrom() = \"unknown\" } // ヒトクラスを継承して男クラスと女クラスを作る class Man(name: String) : Person(name) { // nameLength を Man 用の振る舞いにオーバーライド override val nameLength: Int get() { print(\"$name (man) \") // 名前の後ろに (man) を表示するようにした return name.length } // bornFrom を Man 用の振る舞いにオーバーライド override fun bornFrom() = \"mud\" // 土から生まれた fun doShibakari() { println(\"山へ芝刈りに\") } } class Woman(name: String) : Person(name) { // nameLength を Woman 用の振る舞いにオーバーライド override val nameLength: Int get() { print(\"$name (woman) \") // 名前の後ろに (woman) を表示するようにした return name.length } // bornFrom を Woman 用の振る舞いにオーバーライド override fun bornFrom() = \"rib\" // 肋骨から生まれた fun doSentaku() { println(\"川へ洗濯に\") } } fun main(args: Array) { val p = Person(\"p\") p.nameLength // 1 p.bornFrom() // unknown // 各々、オーバーライドしたメソッドとプロパティを使ってみる val m = Man(\"bob\") println(m.name) // bob println(m.nameLength) // bob (man) 3 println(m.bornFrom()) // mud // Man 専用メソッド m.doShibakari() // 山へ芝刈りに val w = Woman(\"alice\") println(w.name) // alice println(w.nameLength) // alice (woman) 5 println(w.bornFrom()) // rib // Woman 専用メソッド w.doSentaku() // 川へ洗濯に } スーパータイプとサブタイプ Man と Woman は継承元のクラスである Person として扱うことができる fun main(args: Array) { // 継承先 (サブタイプ) を、 // 継承元 (スーパータイプ) の変数に入れる val m: Person = Man(\"bob\") // Person (継承元) が持っているプロパティ、メソッドにはアクセスできる // 実装は Man (継承先) に従う println(m.name) // bob println(m.bornFrom) // mud m.doShibakari() // m はあくまで Person なので doShibakari は使えない (コンパイルエラー) } 抽象クラス 抽象クラスを使うと嬉しい場面 サブクラスにオーバーライドを強制する仕組み abstract をつけたメソッドやプロパティは、サブクラスで必ずオーバーライドする必要がある abstract class Person() { // どこから生まれたかメソッドを抽象メソッドに // abstract の場合、スーパークラスでは実装を書かなくてよい abstract fun bornFrom(): String } class Man() : Person() { // スーパークラスでは abstract がついているメソッドなので、 // サブクラスでオーバーライドしないとコンパイルエラーになる override fun bornFrom() = \"mud\" } class Woman() : Person() { // なお、abstract がついてる場合はオーバーライドすることが前提なので、 // スーパークラスの側に open をつけなくて良い override fun bornFrom() = \"rib\" } 使い方 fun main(args: Array) { val p: Person = Person() // Person は abstract なのでインスタンス化はできない val m: Person = Man() // これは OK val w: Person = Woman() // これも OK println(m.bornFrom()) // mud println(w.bornFrom()) // rib } 可視性 パッケージ パッケージ (package) とはクラスを分類する仕組み。基本的に全てのクラスはどこかのパッケージに属している パッケージを指定しない場合、デフォルトのパッケージ (名前はない) に属することになる // パッケージを宣言。車パッケージとする package io.access.car // 以下、本ファイルに書くクラス、関数は io.access.car パッケージに属する class Car(val name: String) fun greet(): String { ... } 他のパッケージから io.access.car パッケージを参照する場合、import 文を用いて利用したいパッケージをインポートする必要がある // 上記の車パッケージとは別のパッケージ。店パッケージとする package io.access.store // car をインポートすると Car を使うことができる // 以下の書き方をすると io.access.car パッケージに含まれるクラス全てがインポートされる import io.access.car.* class Store { val car = Car() } インポートしたクラスに as を使って別名をつけることもできる クラス名が別のパッケージに含まれるクラスと重複したときなどに有用 クラス名が長い場合に短くしたりという使い方も package io.access.store // as を使ってインポートしたクラスに別名をつける import io.access.car.Car as MyCar class Store { // MyCar として利用できる val car = MyCar() } トップレベルの宣言における可視性の指定 宣言したクラスについて、他のパッケージ、他のクラスからどの程度参照可能にするかどうかを指定できる トップレベルでの宣言 (クラスや関数の外での宣言を指す) に対しては、public、internal、private が選択できる 何も記載しなかった場合、public 扱いになる // サンプルパッケージがあったとして package sample // 以下のように関数が宣言されていたとする // public はパッケージ外からもファイル外からもアクセス可能 (デフォルト) public fun publicFunc() { println(\"public!\") } // private は同一ファイル内からのみアクセス可能 private fun privateFunc() { println(\"private!\") } // internal は同一モジュールからのみアクセス可能 // モジュールというのは Maven、Gradle のプロジェクト単位 // 外部には公開したくないが内側では広く使いたい、みたいなときに用いる internal fun internalFunc() { println(\"internal!\") } import sample fun main(args: Array) { publicFunc() // コンパイル OK privateFunc() // コンパイル NG internalFunc() // 場合による } クラス内部の宣言の場合 トップレベルの宣言時に使える 3 種に加えて、protected を使うことができる // スーパークラス open class Person { private fun privateMethod() {} protected fun protectedMethod() {} internal fun internalMethod() {} public fun publicMethod() {} } // サブクラス class Woman: Person() { fun function() { privateMethod() // コンパイル NG publicMethod() // コンパイル OK internalMethod() // 場合による protectedMethod() // コンパイル OK } } // 関係ないクラス class Foot { fun function() { val p = Person() p.protectedMethod() // コンパイル NG p.publicMethod() // コンパイル OK p.internalMethod() // 場合による } } "},"interface.html":{"url":"interface.html","title":"インターフェース","keywords":"","body":"インターフェース インターフェースについて記載します。 ゴール 以下を理解していること。 基本的なインターフェースの作り方、使い方 プロパティ interface をオーバーライドしてクラスを作る デリゲーション インターフェース インターフェースとは？ abstract なクラスに近いが、状態 (バッキングフィールド) を持つことができないクラス 具象（クラス）に対する抽象（インターフェース）として、上位の設計思想を守るため使われることが多い プロパティ、メソッドを持たせることができるが、いずれも abstract になる コンストラクタを持たせることはできない 定義の仕方 // interface と書いて宣言する // Greeter (挨拶するひと) インターフェース interface Greeter { // プロパティ、メソッドを持たせられるが、いずれも abstract // 強制的に abstract になるので、abstract は書かないでも良い (書いても良いが冗長) // また、メンバは全て public 扱いになる val language: String fun sayHello(target: String) } 実装の仕方 クラスを作ってインターフェースを継承する abstract なものをひととおりオーバーライドする (interface を実装する、と呼ぶ) // Greeter interface を実装する EnglishGreeter クラス class EnglishGreeter : Greeter { // val language と fun sayHello を // オーバーライドしないとコンパイルが通らない override val language = \"English\" override fun sayHello(target: String) { println(\"Hello! $target!\") } } ちなみに、クラスの継承はひとつまでなのに対し、インターフェースは複数継承することができる // インターフェースがふたつ以上あったとして... interface Cookie { ... } interface Chocolate { ... } // クラスは複数のインターフェースを継承して実装することができる class Sweet : Cookie, Chocolate { ... // Cookie、Chocolate に含まれるメンバを // 全てオーバーライドする (実装する) 必要がある } デフォルト実装 インターフェースに含まれるメソッドを実装しておくことができる 継承した側でオーバーライドしない場合、デフォルト実装が使われる interface Greeter { // デフォルト実装をもったメソッド fun sayHello(target: String) { println(\"Hello $target!\") } } class EnglishGreeter : Greeter { // sayHello の実装を省略 } fun main(args: Array) { val g: Greeter = EnglishGreeter() g.sayHello(\"takeshi\") // Hello takeshi! } クラスデリゲーション 継承の問題点として、以下のようなものがある こじらせるとクラスがどんどん大きくなってしまう (共通機能をつめこみたくなる) スーパークラスの変更はただちにサブクラスに影響する (変更の影響範囲を小さくできない) 継承せずに別クラスに処理を委譲するやり方をデリゲーションと呼ぶ 継承と委譲それぞれの実装例を見てみよう。 // 継承するパターン // インターフェースの定義 interface Greeter { fun sayHello() fun sayHello(target: String) } // 英語で挨拶クラス open class EnglishGreeter : Greeter { override fun sayHello() { // 名前を省略したら anonymous さんに挨拶する sayHello(\"anonymous\") } override fun sayHello(target: String) { println(\"Hello, $target!\") } } // 名前を指定されたときはすごい挨拶をする // 英語で挨拶クラスを継承して拡張した class EnglishGreeterGreatAgain : EnglishGreeter() { override fun sayHello(target: String) { // スーパークラスの実装を呼び出す super.sayHello(\"$target great again!\") // Hello $target great again! } } fun main(args: Array) { val g = EnglishGreeterGreatAgain() g.sayHello(\"America\") // Hello America great again! g.sayHello(\"Japan\") // Hello Japan great again! g.sayHello(\"Germany\") // Hello Germany great again! g.sayHello() // Hello anonymous great again ← ！？ } 継承で一部分だけ拡張したつもりでいたが、結局のところはスーパークラスの実装への依存があり、制御が難しい場合がある スーパークラスをいじれれば良いが、そうでない場合は思い通りにできない場合も // 委譲するパターン class EnglishGreeterGreatAgain : Greeter { // 継承ではなく、メンバとして値を持つ private val g: Greeter = EnglishGreeter() override fun sayHello() { // 単にメソッドを呼び出す g.sayHello() } override fun sayHello(target: String) { // 拡張してメソッドを呼び出す g.sayHello(\"Hello $target great again!\") } } fun main(args: Array) { val g = EnglishGreeterGreatAgain() g.sayHello(\"America\") // Hello America great again! g.sayHello(\"Japan\") // Hello Japan great again! g.sayHello(\"Germany\") // Hello Germany great again! g.sayHello() // Hello anonymous! } 通常、委譲するほうが継承するよりもコードは多くなる傾向がある 上の例の場合、sayHello() も sayHello(target: String) も要実装になっている ところが、Kotlin の場合、委譲してもコード量を増やさない技が備わっている // コンストラクタで Greeter をとりつつ、\"Greeter by greeter\" と指定して継承 // override してない部分は greeter に委譲するという意味になる class EnglishGreeterGreatAgain(private val greeter: Greeter): Greeter by greeter { // override fun sayHello() は実装しない (= greeter に委譲) // 拡張したいところだけ override override fun sayHello(target: String) { greeter.sayHello(\"Hello $target great again!\") } } fun main(args: Array) { val eg = EnglishGreeter() val g = EnglishGreeterGreatAgain(eg) g.sayHello(\"America\") // Hello America great again! g.sayHello(\"Japan\") // Hello Japan great again! g.sayHello(\"Germany\") // Hello Germany great again! g.sayHello() // Hello anonymous! } インターフェースがあると嬉しい場面 インターフェースを実装したクラスは、インターフェースのほうの「型」として扱うことができる // Greeter インターフェース interface Greeter { fun sayHello(target: String) } // Greeter インターフェースを受け取って呼び出すだけの関数 fun greeting(g: Greeter, target: String) { g.sayHello(target) } // 日本語で挨拶 class JapaneseGreeter : Greeter { override fun sayHello(target: String) { println(\"こんにちは、$target さん！\") } } // 英語で挨拶 class EnglishGreeter : Greeter { override fun sayHello(target: String) { println(\"Hello, $target!\") } } // ドイツ語で挨拶 class GermanyGreeter : Greeter { override fun sayHello(target: String) { println(\"Guten morgen, $target!\") } } fun main(args: Array) { // greeting 関数は Greeter インターフェースを実装したクラスを // 引数にとるので、以下はいずれも有効な書き方 greeting(JapaneseGreeter(), \"world\") // こんにちは、world さん！ greeting(EnglishGreeter(), \"world\") // Hello, world! greeting(GermanyGreeter(), \"world\") // Guten morgen, world! } 実装の中身を入れ替えたいときに便利 テスト用に常に OK を返すだけのクラスにしたい SQLite を使っていたが Postgres に変更したい 等など "},"generics.html":{"url":"generics.html","title":"ジェネリクス","keywords":"","body":"ジェネリクス ジェネリクスについて記載します。 ゴール 以下を理解していること。 ジェネリクスの使い方、使いどころ ジェネリック関数 ジェネリック制約 ジェネリクス ジェネリクスとは 利用する型を仮で書いておいて、実際の型はあとから指定するという記述方法。 任意の型をパラメータにしたいときはどのような書き方ができるか？ // value というプロパティを持った Container というクラスを仮定 // value の型は Any class Container(val value: Any) fun main(args: Array) { // 値を入れるとき val intContainer: Container = Container(10) // OK val strContainer: Container = Container(\"hello!\") // OK // 値を取り出すとき // as ◯◯ をつけてキャストする必要がある val i = intContainer.value as Int // OK val s = strContainer.value as String // OK // ところがキャストは失敗する可能性がある val i2 = intContainer.value as String // 実行時に ClassCastException の例外を吐かれる } 上記の例の場合、ClassCastException が出ないように作るのはプログラマの責任 ジェネリクスを使うと、コンパイル時に妥当かチェックしてもらえる // any を使わず、ジェネリクスを使った場合 // value の型は として仮置きしている class Container(val value: T) fun main(args: Array) { // 値を入れるとき val intContainer: Container = Container(10) // 値を取り出すときにキャスト不要 // キャスト不要なので ClassCastException も起こらない val i:Int = intContainer.value // 使い方が違っていればコンパイル時にエラーになる val s: String = intContainer.value // コンパイルエラー } ジェネリック関数 ジェネリクスは関数、メソッド、プロパティにも適用できる // data クラスにしてみる data class Container(val value: T) // 関数にジェネリクスを用いる場合 fun box(value: T): Container { return Container(value) } val T.string: String get() = toString() fun main(args: Array) { val container = box(100) println(container.string) // Container(value=100) } ジェネリック制約 ジェネリクスでは任意の型を扱うことができるが、「何らかのクラスのサブクラスだけに制限したい」という制限も可能 interface IFA interface IFB class A() class B() // IFA interface を継承した T に限る fun main(args: Array) { A() // OK A() // OK B() // OK B() // error: type argument is not within its bounds: should be subtype of 'IFA' } where を使って制約を複数にすることもできる interface IFA interface IFB interface IFC: IFA, IFB // IFC は IFA、IFB を継承 class A where T : IFA, T: IFB // T は IFA のサブクラスかつ IFB のサブクラスに限る fun main(args: Array) { A() // error: type argument is not within its bounds: should be subtype of 'IFB' A() // error: type argument is not within its bounds: should be subtype of 'IFA' A() // OK } 以下については記載を省略 変位指定 スター投影 具象型 "},"null_safe.html":{"url":"null_safe.html","title":"Null安全","keywords":"","body":"Null安全 Null 安全について記載します。 ゴール 以下について理解していること。 Null 安全が必要な背景 スマートキャスト 安全呼び出し演算子 (?) 強制呼び出し演算子 (!!) エルビス演算子 (?:) 安全キャスト null って何よ null そのものの意味は、\"空\" とか \"無\" とか。ドイツ語らしい。 変数に null を入れると、その変数はどこも参照していない (null を参照している) 状態になる null を参照しているオブジェクトのメソッド呼び出しは例外 (NullPointerException) を発生させる NullPointerException になるのが期待動作ということは基本的になく、概してプログラミングのミスで発生する Java のコードで NullPointerException が出る例は以下のような場合。 以下、Java のコード例には「Java」と記載 (特に注釈がなければ Kotlin のコード例) Java String s = null; // null を入れる s.toUpperCase(); // NullPointerException 発生 従来の null との戦い NullPointerException と null チェック NullPointerException が起きないように、変数を参照する前に変数が null でないかを確認する必要が生じることがしばしばある 実はきっちり対処しようとするとそれなりに手間 Java // 上述のコード例における NullPointerException を回避する String s = null; if (s != null) { // null じゃないことを確認する s.toUpperCase(); } ところが、 Java の言語仕様上、変数は基本的に全て null になりうる その点だけ捉えると全ての変数について使う前に null チェックするのが妥当か…？ 文脈上、絶対に null でないことが確定しているような場合はチェックするべき？ Java String s = \"hoge\"; // s は明らかに null じゃないのでチェックしないで良さそう String ss = Fuga(); // 文字列か null を返す関数だとしたら // ss は要チェック チェックの要・不要を判断するのはプログラマ → 往々にして間違いが起こり得る アノテーションによる null 回避という案 Android Java では @NonNull のようなアノテーションをメソッドに付与できる @NonNull をつけておくと、コンパイル時にある程度 null にならないことをチェックできる しかし基本的に無力 表明するためのものでありドキュメンテーションの色合いが強い IDE は @NonNull なところに null になりうる変数を渡すと警告してくれる (こともある) 制約に違反するコードがあってもコンパイルエラーにはしてくれない Java // アノテーションによって本メソッドは null を返さないことを表明する @NonNull String Fuga() { // ... return null; // しかし null は返すことはできてしまう (コンパイルエラーではない) } // null になりうることも表明できる @Nullable String Piyo() { // ... } null 安全 そんなわけで null にはさんざん苦戦してきた Kotlin では、「null になりうるか」「null になりえないか」を「型」で区別している // たとえば、以下のコードはコンパイルに失敗する // String は「null になりえない」型であるから val s: String = null // error: null can not be a value of a non-null type String // 「null になりえる」型を宣言するためには、? を補う // 以下はコンパイル OK val s: String? = null // ただし、「null になりえる」の状態のままではメソッド、プロパティの呼び出しができない // error: only safe (?.) or non-null asserted (!!.) calls are // allowed on a nullable receiver of type String? s.toUpperCase() // たとえ値が入っていても同様 val ss: String? = \"hoge\" // error: only safe (?.) or non-null asserted (!!.) calls are // allowed on a nullable receiver of type String? ss.toUpperCase() スマートキャスト 「null になりえる」の状態では、メソッドやプロパティが呼び出せない メソッドやプロパティを呼び出すためには、「null になりえる」の状態から「null になりえない」に変換が必要 たとえば if 文による null チェックで対象が「null になりえない」ことが分かれば良い // スマートキャストを使った「null になりえる」から「null になりえない」への変換 val s: String? = \"hoge\" // 「null になりえる」状態 if (s != null) { // null チェックすることで s は「null になりえない」になる println(s.toUpperCase()) // メソッドが呼び出せる } 安全呼び出し 対象が「null だったら null、null じゃなかったら中身」を使うやり方 // ? をつけると「null になりえる」型 val s: String? = \"hoge\" // 通常、このままでは s のメソッドを呼べないが、 // ? を補うことで呼び出せる val u = s?.toUpperCase() // 上記は以下と同じ処理 val u = if (s != null) { s.toUpperCase() } else { null } メソッドの引数に「null になりうる」を渡す場合 // 以下の関数の引数の型は「null になりえない」という記述 fun greet(name: String) { println(\"hello, $name!\") } val s: String? = \"hoge\" greet(s) // コンパイルエラー if (s != null) { greet(s) // これなら OK } 上記のような例の場合に、let を用いることができる let は任意の型とラムダ式を引数にとり、ラムダ式を呼び出す val s: String? = \"hoge\" // コンパイル OK // s が null ならラムダ式は呼び出されない s?.let { greet(it) } 強制呼び出し !! を使うと「null になりうる」を「null になりえない」に強制的に変換する 中身が本当に null だったら NullPointerException になっちゃうので、基本的に使わないで済ませたい 対象の変数が 100%ヌルでない ということが分かっているなら使っていいかもしれない が、そういうときにもあえて強制呼び出しオペレータを用いる必要はなく、もっと良い書き方ができるはず val s: String? = \"hoge\" s!!.toUpperCase() // コンパイルOK、実行も可能 val s: String? = null s!!.toUpperCase() // コンパイルOK、だが実行時に例外 (NullPointerException) を吐く エルビス演算子 null のときに返す値を指定できる ちなみに三項演算子（a > 0 ? \"1以上\" : \"0以下\"）とは別物 三項の方はKotlinでは使えない val s: String? = null s ?: \"null です！\" // null だったら「null です！」を返す // 以下と同義 if (s != null) { s } else { \"null です！\" } 安全キャスト 型をキャストする際にも ? が使える キャストに失敗したときに例外ではなくて null が返る val a: Any = \"string\" // String を Any に入れる println(a as String) // String へのキャストは OK (\"string\" が表示される) println(a as Int) // java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer val a: Any = \"string\" // String を Any に入れる println(a as? String) // String へのキャストは OK (\"string\" が表示される) println(a as? Int) // null が表示される "},"tips.html":{"url":"tips.html","title":"その他豆知識","keywords":"","body":"その他豆知識 その他、豆知識を記載します。 ゴール 以下について理解していること ObjectとCompanion Object 演算子オーバーロード 等価、同値 (=== と ==) 分解宣言 列挙型 例外 再起呼び出しと末尾再起呼び出し最適化 ローカル関数 coroutine apply also by lazy ※一部は時間の都合上、記載省略 ObjectとCompanion Object Object Objectは一言で言えば「シングルトン（Singleton）なクラス」だが、ここでは使用例を見せながら説明する。 どこからでも呼び出せるログ出力関数が欲しいとしよう。 今まで習った内容を使って書くとこうなる。 class Logger { val TAG = \"MyApp\" fun debug(text: String) { println(\"$TAG: $text\") } } fun main() { println(\"Logging to ${Logger().TAG}.\") Logger().debug(\"print\") } 出力結果 Logging to MyApp. MyApp: print ただし、このコードには問題があって、Logger().で毎回異なるインスタンス（オブジェクトの実体）が作られる。この例だとmainの中で2回作られている。 もし、debugがあちこちから大量に呼ばれたら…たちまちインスタンスが乱立して、メモリを圧迫し、アプリの動作が重くなるだろう。 それを避けるため、クラスをobject識別子で定義する。 object Logger { val TAG = \"MyApp\" fun debug(text: String) { println(\"$TAG: $text\") } } fun main() { println(\"Logging to ${Logger.TAG}.\") Logger.debug(\"print\") } こうすると、クラスLoggerと変数TAGは何回呼ばれても常に同じインスタンスを返す。何度呼ばれても、メモリ圧迫量は変わらない。これがシングルトン。 呼び出し方はLogger.に変わる。 Companion Object さて、上記の例だと、TAGもdebugもシングルトンとして生成されるが、時にはTAGだけに適用したい場合もある。 その場合、companion object識別子を使うと、TAGをLoggerクラスに属するシングルトン変数、つまり「定数」にできる。 class Logger(outputFilePath: String) { companion object { val TAG = \"MyApp\" } fun debug(text: String) { // TODO 実際はoutputFilePathにファイル出力するよう作り替える println(\"$TAG: $text\") } } fun main() { println(\"Logging to ${Logger.TAG}.\") Logger(\"/log.txt\").debug(\"print\") } mainを見ると、Loggerは普通のクラスだが、TAGはシングルトンであることがわかる。 実際、Key/Valueを扱い、Keyだけが定数、という実装がよくある。 また、Androidでは画面から他画面のデータ渡しでリクエストコードやKey/ValueペアのBundleを使うので、そういうときCompanion Objectはよく使われる。 余談 勘のいい人なら気づいたであろうが、この例の場合、実はクラスを使わずdebug()を実装する方法もある。 val TAG = \"MyApp\" fun debug(text: String) { println(\"$TAG: $text\") } fun main() { debug(\"print\") } このようにトップレベル関数を使うのが一番シンプルである。 今までの例は、シングルトンをわかりやすく説明するためである。 また、Javaを知ってる人ならstaticがあるじゃないかと思うかもしれないが、staticはKotlinでは使えない。 静的なものは非オブジェクトだから、オブジェクト指向の言語において不要だろうという言語設計思想のため。 まとめ Objectは、「クラス/変数として毎回同じインスタンスを返したい場合」に使う Companion Objectは、「毎回同じインスタンスを返す変数（定数）をクラスに持たせたい場合」に使う と覚えておこう。 列挙型 定数を列挙する場合に便利な書き方。 enum class Kanto { IBARAGI, TOCHIGI, GUNMA, SAITAMA, CHIBA, TOKYO, KANAGAWA } fun main() { println(\"Kanto Prefecture List: \") for (prefecture in Kanto.values()) { println(prefecture) } println(\"I'm living in ${Kanto.TOKYO}.\") } 例外 異常が起こった場合、関数は例外をスローできる。関数の呼び出し元では、その例外をキャッチして処理できる。 fun validation(percentage: Int) { if (percentage !in 0..100) { throw IllegalArgumentException(\"A percentage must be between 0 and 100 [parameter: $percentage]\") } } fun main() { validation(101) } 値が0〜100の範囲に収まっていない場合は、IllegalArgumentExceptionをスローする。 Exception in thread \"main\" java.lang.IllegalArgumentException: A percentage must be between 0 and 100 [parameter: 101] at FileKt.validation (File.kt:3) at FileKt.main (File.kt:8) at FileKt.main (File.kt:-1) 再帰呼び出し 普通の再帰呼び出し // Long のリストを引数にとって合計を返す関数 // sum 関数内で sum 自身を呼び出している fun sum(numbers: List): Long = if (numbers.isEmpty()) 0 else numbers.first() + sum(numbers.drop(1)) // 上記のコードは引数に渡した配列が超長い場合などにちゃんと動かなくなる // (stack overflow してしまう) sum((1L..123456).toList()) // stack overflow しちゃう！ 末尾呼び出し最適化 // 再帰的に関数を呼び出す場合において、その関数呼び出しが関数の一番最後にくる場合、 // 「末尾呼び出し最適化 (Tail Call Optimization)」と呼ばれる最適化を行うことができる // * 関数定義の頭に tailrec をつける // * 再帰呼び出しを関数の最後にもっていく tailrec fun sum(numbers: List, acc: Long = 0): Long = // ← tailrec というのをつけた if (numbers.isEmpty()) acc else sum(numbers.drop(1), acc + numbers.first()) // sum の再帰呼び出しが関数の最後にきている // 動く！ sum((1L..123456).toList()) ローカル関数 ローカル関数は関数の中に関数を定義できる仕組み 他の関数からは呼び出すことができない (関数内にスコープを限定) 以下はローカル関数と再帰呼出しの組み合わせ fun sum(numbers: List): Long { // 引数を 2 つとる関数をローカル関数化し、 // 外面を良く (引数 1 個で済むように) した tailrec fun go(numbers: List, acc: Long): Long = if (numbers.isEmpty()) acc else go(numbers.drop(1), acc + numbers.first()) return go(numbers, 0) } apply オブジェクトに対し、プロパティの変更を一括適用する class Company ( var name: String, var numberOfEmployees: Int = 0 ) fun main(args: Array) { val c = Company(\"ACCESS\", 310).apply { // 今年の新卒社員数を加算 numberOfEmployees += 15 } val s = \"${c.name} has ${c.numberOfEmployees} employees.\" println(s) // ACCESS has 325 employees. } プロパティの数が多い場合、c.xxx = yyyみたいな記述を繰り返す手間が省ける also applyと似てるが、alsoはラムダ式の中で別の名前を付けることができる デフォルトはit つまり、applyの場合はラムダ式の内外でthisの指す先が異なるが、alsoを使うと同じになる letとも似てるが、letは最後の行を返すのに対し、alsoは元のオブジェクトを返す val s = \"access\".also { it.toUpperCase() } println(s) //=> ACCESS by lazy 遅延プロパティと呼ばれる 最初にアクセスがあった時に、ラムダの中身を計算し、最終行の値をvalに保持する それ以降は、単に保持された結果を返す val greetMessage: String by lazy { println(\"First time!\") \"Hello!\" } fun main(args: Array) { println(greetMessage) // \"First time!\\nHello!\" println(greetMessage) // \"Hello!\" } 実際は、画面の起動時には設定できないけど、更新時にはじめて設定できるものとかに使う それはvarでも実装できるが、by lazyの場合valにできるのが利点 "},"exercise1.html":{"url":"exercise1.html","title":"Exercise (1)","keywords":"","body":"Exercise (1) Hello World! まずはこれ！ソースをコンパイルしてとりあえず動かすところまでやってみよう！ 環境構築の方法については、開発環境の構築 を参照のこと。 最初のプロジェクトを作成したら、以下のソースコードを書いて、Run してみよう！ fun main(args: Array) { println(\"Hello world!\") } もしAndroid StudioでKotlinTrainingプロジェクトを使っている場合は、SampleTest.ktに以下のように書こう！ @Test fun testExercise() { println(\"Hello world!\") } Fizz Buzz 基本的な文法、関数の使い方を抑えたところで、以下の練習をやってみよう！ 入力は 1〜100 3の倍数の時は「Fizz」を出力 5の倍数の時は「Buzz」を出力 3の倍数かつ5の倍数の時は「FizzBuzz」を出力 それ以外のときはそのまま数字を出力 出力例 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz ... FizzBuzz 91 92 Fizz 94 Buzz Fizz 97 98 Fizz Buzz ポイント if 文、for ループが使えれば解けるはず when を使って短く書いたりもできる fun main(args: Array) { for (i in 1..100) { // 実装する } } ところで上記のコードだと単体テストが書きにくい... どのようにしたら単体テストが書きやすくなるか？ 単体テストも書いてみよう！ // 単体テスト例 // * fizzbuzz テスト用のクラスを新規に作って書いてもいい // * 既存のテストクラスにメソッドを追加してもよい package io.access.kotlintraining import org.junit.Test import kotlin.test.assertEquals class FizzBuzzTest { @Test fun testFizzBuzz() { // TODO: テストを書く // assertEquals 等の assert 系 function を使おう // 以下の kotlin.test パッケージのリファレンスも参照のこと // https://kotlinlang.org/api/latest/kotlin.test/kotlin.test/index.html } } うるう年 入力された数字を西暦としたときに、うるう年かどうか判定する関数を書いてみよう！ 入力は 0 以上の Int うるう年ならば true、そうでないならば false を返す ところでうるう年って？ 年が 4 で割り切れる場合、その年はうるう年として扱う。ただし、100 で割り切れてかつ 400 で割り切れない年は除く 1700、1800、1900、2100、2200、2300、2500、2600 はうるう年ではない 1600、2000、2400 はうるう年 単体テストも書いてみよう！ // うるう年かどうかを判定する関数 fun isLeapYear(y: Int): Boolean { // TODO: 実装する } 累乗 数字をふたつ引数にとって (a、n とする)、a の n 乗を返す関数を書いてみよう！ 入力は a、n 共に任意の数 (正の数でも負の数でも浮動小数点でも OK) とする …とすると考慮することが非常に増えるので、ここではひとまず、いずれも正の整数とする 余裕があったら浮動小数点も取れるようにしてみよう！ fun power(a: Int, n: Int): Long { if (a "},"exercise2.html":{"url":"exercise2.html","title":"Exercise (2)","keywords":"","body":"Exercise (2) クラスの使い方を抑えたところで、以下の練習をやってみよう！ 奇数か偶数か Int を拡張して、isOdd、isEven メソッドを追加してみよう！ isOdd ... 数が奇数であるときに true を返し、偶数のときに false を返すメソッド isEven ... 数が偶数であるときに true を返し、奇数のときに false を返すメソッド 使い方イメージ fun main(args: Array) { val a = 5 a.isOdd() // true a.isEven() // false } n 面のサイコロ サイコロクラス (Dice クラス) を作るよ！プロパティ、メソッドとして以下を備えるとする。 n 面のサイコロを表す n: Int をコンストラクタで取る 「サイコロを振る」メソッド roll を備える roll は Int をひとつ返す (返る値は 1 以上 n 以下) メソッド ちなみに 100 回振ると壊れて例外 Exception(\"I was broken\") を吐く 以後、roll を呼び出すと例外を吐く 別の Dice インスタンスを作ればまた roll できる ランダムな数を得る方法は、たとえば以下 import java.util.Random fun main(args: Array) { val random = Random() val n = random.nextInt(100) // 0〜99 までの範囲の値がランダムで返る println(n) } 以下、Dice クラスの使い方イメージ import java.util.Random // TODO: class Dice を書く fun main(args: Array) { val d = Dice(16) for (i in 1..100) { println(d.roll()) // 1〜16 までの数字 } println(d.roll()) // Exception } 呼び出した回数をカウントする カスタムセッターを使って、何度呼び出されたかをカウントしてみよう！ 使い方イメージ class MyCustomClass { var counter: Int = 0 var propertyWithCounter: Int = 0 /* TODO: ここにカスタムセッターを書く */ } fun main(args: Array) { val p = MyCustomClass() p.propertyWithCounter = 123 p.propertyWithCounter = 456 p.propertyWithCounter = 789 println(p.counter) // 3 } 世界のナベアツ ところで、世界のナベアツはご存知でしょうか。 現在は落語家になっていらっしゃる。高座名は「桂三度」 彼の持ちネタ「3の倍数と3が付く数字のときだけアホになります」というのがいっとき (2008年前後と思われる) 流行った 詳細は wikipedia 等を参照されたし ということで、ナベアツクラスを作ってみよう！ next というメソッドを持つ。戻り値は String ナベアツは内部的にカウンターを持っており、next が呼び出されるたびにカウンターを 1 つずつ増やしていく 内部カウンターが「3の倍数と3が付く数字のとき」、next は Aho を返す それ意外のときは、カウンターの値を文字列にしたものをそのまま返す class NabeAtsu { // TODO: 実装する fun next(): String { // TODO: 実装する } } // 呼び出しイメージ fun main(args: Array) { val n = NabeAtsu() for (i 1..100) { println(n.next()) } } # 実行例 (実際は改行されますがスペースの関係で横に書きます) 1 2 Aho 4 5 Aho 7 8 Aho 10 11 Aho Aho 14 Aho 16 17 Aho 19 20 Aho 22 Aho Aho 25 26 Aho 28 29 Aho Aho Aho Aho Aho Aho Aho Aho Aho Aho 40 41 Aho Aho ... "},"exercise3.html":{"url":"exercise3.html","title":"Exercise (3)","keywords":"","body":"Exercise (3) ヌルと戦うJavaプログラマーにKotlinを教えよう！ あなたの部署には、Kotlinをまったく知らないJava開発者のN内さんがいます。 N内さんは、上司の指示でJavaのコードをKotlinに書き直して、あなたにレビューをお願いして来ました。 N内さんは「漏れなくnullチェックできてるし！！」と自信満々だが、そのコードはビルドすら通りません。 あなたは呆れ顔で、このコードを修正してあげる必要があります。 問題 正しい出力結果 To: antonio@abc-company.com message: Hello, Antonio! が出るよう、以下のコードをできる限り短く読みやすく修正してください。 ifを使うのは1回まで class Client (val personalInfo: PersonalInfo?) class PersonalInfo (val email: String?) interface Mailer { fun sendMessage(email: String, message: String) } class CosmosMailer: Mailer { override fun sendMessage(email: String, message: String){ println(\"To: $email\\nmessage: $message\") } } fun sendMessageToClient(client: Client?, message: String?, mailer: Mailer) { if (client == null || message == null) { return } val personalInfo: PersonalInfo = client.personalInfo if (personalInfo == null) { return } val email: String = personalInfo.email if (email == null) { return } mailer.sendMessage(email, message) } fun main(args: Array) { val personalInfo: PersonalInfo = PersonalInfo(email: \"antonio@abc-company.com\") val client: Client = Client(personalInfo: personalInfo) val mailer: Mailer = CosmosMailer() sendMessageToClient( client: client, message: \"Hello, Antonio!\", mailer: mailer ) } 参考までに、下記が移植前の Java コードの一部 引数のアノテーションによると、client、message は null の可能性がある 引数のアノテーションによると、mailer は null の可能性がない 途中で null に出くわしたらに何もせず return している Java public void sendMessageToClient( @Nullable Client client, @Nullable String message, @NonNull Mailer mailer) { if (client == null || message == null) return; PersonalInfo personalInfo = client.getPersonalInfo(); if (personalInfo == null) return; String email = personalInfo.getEmail(); if (email == null) return; mailer.sendMessage(email, message); } "},"./":{"url":"./","title":"Introduction","keywords":"","body":"Kotlin introduction 目次 はじめに Kotlin について 開発環境の構築 基本的な文法 関数 ちょっと特殊な関数 クラス 継承・抽象クラス インターフェース ジェネリクス Null安全 その他豆知識 Exercise (1) Exercise (2) Exercise (3) "}}